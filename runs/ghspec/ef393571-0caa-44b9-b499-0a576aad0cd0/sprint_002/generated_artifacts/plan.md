# Implementation Plan: Add Email Field to Student Entity

---

## INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Student Entity Management Application

## Version: 1.0.1
## Date: 2023-10-07

## Overview
This implementation plan outlines the technical changes required to enhance the existing Student entity by adding an email field. This addition aims to improve data completeness and support future functionalities such as communication with students. The plan includes modifications to the data model, API contracts, and implementation approach while ensuring backward compatibility.

## Architecture
The existing architecture leveraging FastAPI framework and SQLite for data storage will remain intact. The new email field will be added to the current Student entity model, integrating seamlessly into the existing API structure during the migration process.

### System Components
1. **FastAPI Application**: Existing service responsible for handling API requests.
2. **SQLite Database**: Updates needed for the schema to include the email field.
3. **Pydantic Models**: Modifications to existing models to include validation for the new email field.

## Technical Stack
- **Programming Language**: Python 3.11+
- **Web Framework**: FastAPI
- **Database**: SQLite
- **Data Validation**: Pydantic
- **Documentation**: OpenAPI (Automatically generated by FastAPI)
- **Testing Framework**: pytest

## Module Boundaries and Responsibilities

### Modules
1. **API Module**
   - Existing responsibility for exposing RESTful endpoints and response validation.
   - Needs to be updated to handle the new email field in requests and responses.

2. **Database Module**
   - Modify current database interactions to reflect schema changes.
   - Implement migration strategy to preserve existing data.

3. **Service Module**
   - Update business logic for managing student data to include the new email field.

## Data Model

### Updated Pydantic Model

```python
from pydantic import BaseModel, EmailStr, constr

class StudentCreate(BaseModel):
    name: constr(min_length=1)  # Required field
    email: EmailStr  # New field with validation for email format

class StudentResponse(BaseModel):
    id: int
    name: str
    email: str  # Return email field in response
```

### Updated SQL Schema
The existing student table will be modified:
```sql
CREATE TABLE students (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE
);
```

## API Contracts

### Updated Endpoints
1. **POST /students**
   - **Description**: Add a new student (now including email)
   - **Request Body**:
     ```json
     {
         "name": "string",  // Required
         "email": "string"  // Required
     }
     ```
   - **Response**:
     - **201 Created**: On successful creation
     - **400 Bad Request**: If name is missing or email is improperly formatted.
     ```json
     {
         "error": {
             "code": "E001",
             "message": "Name is required."
         }
     }
     ```

2. **GET /students**
   - **Description**: Retrieve the list of all students (including emails)
   - **Response**:
     ```json
     [
         {
             "id": 1,
             "name": "John Doe",
             "email": "john@example.com"
         },
         {
             "id": 2,
             "name": "Jane Smith",
             "email": "jane@example.com"
         }
     ]
     ```

## Implementation Approach

### Setup
1. **Update Project Structure**: 
   - No changes are needed for folder structure, but existing files will require modifications.
   - Update `README.md` to reflect new API functionality.

2. **Dependencies**: No new dependencies are required for this feature since email validation is handled by Pydantic.

### Development Steps
1. **Database Migration**: Implement a migration strategy to add the email column to the existing Student table:
   - Use `aiosqlite` for running migrations.
   - Ensure existing students are updated with null emails (if retrofitting is necessary) and handle it in a manner that respects data integrity.
   
    ```python
    import aiosqlite

    async def migrate():
        async with aiosqlite.connect("students.db") as db:
            await db.execute("ALTER TABLE students ADD COLUMN email TEXT NOT NULL UNIQUE")
            await db.commit()
    ```

2. **API Endpoints**: Update existing POST and GET methods in `student.py`. Modify logic to handle the new email field:
   ```python
   from fastapi import FastAPI, HTTPException
   from .models.student import StudentCreate, StudentResponse
   
   @app.post("/students", response_model=StudentResponse)
   async def create_student(student: StudentCreate):
       # Logic to add the student while ensuring email uniqueness and validation
   ```

3. **Data Validation**: Ensure Pydantic validates the email field upon student creation requests.

4. **Error Handling**: Make sure to add error responses in case of invalid email format and duplication errors from the database.

5. **Testing**: Write tests to ensure new functionality is working properly:
   - Test creation of a student with valid and invalid email formats.
   - Test retrieval of students ensuring emails are correctly included.
   - Example test scenario for email validation:
   ```python
   def test_student_creation_invalid_email(client):
       response = client.post("/students", json={"name": "Test Student", "email": "not-an-email"})
       assert response.status_code == 400
       assert response.json()["error"]["code"] == "E002"  # Assuming E002 for invalid email format
   ```

## Scalability Considerations
The application remains stateless to support potential horizontal scaling. Should increased performance requirements occur, consider upgrading SQLite to a more robust database solution like PostgreSQL.

## Security Considerations
Ensure proper validations prevent XSS and SQL injection vulnerabilities. Continue using environment variables for sensitive configurations.

## Deployment Considerations
- Deploy migrations safely ensuring no downtime for existing users.
- Use Docker for consistent environment setups across different stages (development, testing, production).

## Documentation
- Update auto-generated API documentation to reflect new fields and endpoints using FastAPIâ€™s built-in OpenAPI support.
- Detailed explanations regarding migration, new request bodies, and responses should be added to the `README.md`.

## Testing Strategy
- Aim for a minimum of 70% test coverage on added functionalities. Focus on:
   - POST method scenarios (successful addition, invalid email, missing fields).
   - GET method verification for returned student data structure.

## Conclusion
This implementation plan provides a structured approach to enhance the Student Entity by adding an email field. It ensures that the necessary modifications to data models, API contracts, and associated logic are carried out efficiently while maintaining backward compatibility and preserving the existing data integrity. Following this plan will result in a robust, scalable solution that meets the specified requirements effectively.