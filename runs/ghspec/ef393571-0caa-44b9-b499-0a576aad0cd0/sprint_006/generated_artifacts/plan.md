# Implementation Plan: Add Teacher Relationship to Course Entity

---

## Version: 1.0.0  
## Date: 2023-10-07

## Overview
This implementation plan outlines the technical changes required to establish a relationship between the Course and Teacher entities in the existing educational management system. This feature will enable each Course entity to be associated with a specific Teacher, thus improving course management and laying the groundwork for future interactions between teachers and students. 

## Architecture
The architecture will be based on the FastAPI framework, alongside SQLite for data storage. The Course table schema will be modified to include a foreign key reference to the Teacher table. This change will ensure that each course can have an associated teacher, enhancing data tracking and management capabilities.

### System Components
1. **FastAPI Application**: Extend the existing application to provide new functionality for managing course-teacher relationships.
2. **SQLite Database**: Modify the Course table schema to include the relationship to the Teacher table.
3. **Pydantic Models**: Update data models to validate inputs and outputs related to the associations.

## Technical Stack
- **Programming Language**: Python 3.11+
- **Web Framework**: FastAPI
- **Database**: SQLite
- **Data Validation**: Pydantic
- **Documentation**: OpenAPI (Automatically generated by FastAPI)
- **Testing Framework**: pytest

## Module Boundaries and Responsibilities

### Modules
1. **API Module**
   - Update the existing Course API endpoints to include functionality for associating a teacher.
   
2. **Database Module**
   - Modify the existing Course schema to accommodate the new teacher relationship.
   - Implement a migration strategy to ensure data integrity.
   
3. **Service Module**
   - Implement business logic for handling course updates with teacher associations.

## Data Model

### Updated Course SQL Schema
The SQL schema will be modified as follows:
```sql
ALTER TABLE course ADD COLUMN teacher_id INTEGER REFERENCES teacher(id);
```

### Pydantic Models
Add a new pydantic model for creation and update requests related to courses:
```python
from pydantic import BaseModel, Field

class CourseUpdateRequest(BaseModel):
    """Model for updating a course with a teacher association."""
    teacher_id: int = Field(..., example=1)
```

### Course Response Model Update
```python
class CourseResponse(BaseModel):
    """Model for the response containing course details."""
    id: int
    name: str
    level: str
    teacher_id: int

    class Config:
        schema_extra = {
            "example": {
                "id": 1,
                "name": "Mathematics",
                "level": "Intermediate",
                "teacher_id": 1
            }
        }
```

## API Contracts

### Endpoints

1. **PATCH /courses/{course_id}**
   - **Description**: Update an existing course to associate a teacher.
   - **Request Body**:
     ```json
     {
         "teacher_id": "integer"
     }
     ```
   - **Response**: 
     - **200 OK**: On successful course update.
       ```json
       {
           "id": "integer",
           "name": "string",
           "level": "string",
           "teacher_id": "integer"
       }
       ```
     - **400 Bad Request**: If input validation fails or if the teacher is already assigned to an overlapping course.
       ```json
       {
           "error": {
               "code": "E003",
               "message": "Teacher is already assigned to another course that overlaps with the selected course timing."
           }
       }
       ```

2. **GET /courses/{course_id}**
   - **Description**: Retrieve the course details including associated teacher information.
   - **Response**:
   ```json
   {
       "id": 1,
       "name": "Mathematics",
       "level": "Intermediate",
       "teacher_id": 1
   }
   ```

## Implementation Approach

### Setup
1. **Update Project Structure**: 
   - Introduce a new file `api/courses.py` for managing course-related functionalities.
   - Update `README.md` to include new API documentation for the course-teacher relationship.

### Development Steps

1. **Database Migration**: Implement a migration script to add the `teacher_id` column to the Course table, ensuring existing records remain valid.
   ```python
   async def migrate_course_teachers():
       async with aiosqlite.connect("database.db") as db:
           await db.execute("ALTER TABLE course ADD COLUMN teacher_id INTEGER REFERENCES teacher(id);")
           await db.commit()
   ```

2. **API Endpoints Creation**: Define the RESTful endpoints in `api/courses.py` to handle the association between courses and teachers:
   ```python
   from fastapi import APIRouter, HTTPException
   from .models.courses import CourseUpdateRequest, CourseResponse
   import aiosqlite

   router = APIRouter()

   @router.patch("/courses/{course_id}", response_model=CourseResponse)
   async def update_course(course_id: int, request: CourseUpdateRequest):
       async with aiosqlite.connect("database.db") as db:
           # Validate conditions for overlapping course assignments
           # Fetch overlapping courses for the teacher_id provided
           # Update course if no overlaps are found
           result = await db.execute(
               "UPDATE course SET teacher_id = ? WHERE id = ?",
               (request.teacher_id, course_id)
           )
           if result.rowcount == 0:
               raise HTTPException(status_code=404, detail="Course not found or update conflict occurred.")
           await db.commit()

           # Return the updated course details
           return await get_course_by_id(course_id)

   async def get_course_by_id(course_id: int):
       async with aiosqlite.connect("database.db") as db:
           cursor = await db.execute("SELECT id, name, level, teacher_id FROM course WHERE id = ?", (course_id,))
           course = await cursor.fetchone()
           return CourseResponse(id=course[0], name=course[1], level=course[2], teacher_id=course[3])
   ```

3. **Validation Logic**: Implement validation logic to check if the teacher is already associated with a conflicting course. This logic will be invoked in the patch method before updating the teacher association.

4. **Testing**: Create tests to cover the endpoint functionalities such as updating a course with a teacher, checking course details, and ensuring validation works for overlapping course assignments.
   ```python
   def test_update_course_with_teacher(client):
       response = client.patch("/courses/1", json={"teacher_id": 1})
       assert response.status_code == 200  # Proper handling

   def test_update_course_with_overlap(client):
       response = client.patch("/courses/2", json={"teacher_id": 1})
       assert response.status_code == 400  # Handling teacher overlap
   ```

## Scalability Considerations
The implementation is designed with future scalability in mind, enabling easy addition of functionalities related to teacher-course management without significant rewrites.

## Security Considerations
Ensure all input validation is properly enforced to avoid SQL Injection risks, especially when dynamically querying the database for overlapping courses or updating teacher associations.

## Deployment Considerations
- Execute the migration on the production database to add the `teacher_id` column to the Course table, ensuring minimal or no downtime.
- Verify the integrity of existing records after migration completes before enabling the new endpoints.

## Documentation
- Update the API documentation in `README.md` to include additional information about the new functionality for course-teacher associations.
- Provide specific examples of payloads for better developer understanding.

## Testing Strategy
Ensure a minimum of 70% code coverage for all new functionalities related to the teacher association, with particular focus on validation and business logic checks.

## Conclusion
This implementation plan provides a comprehensive approach to integrating the teacher relationship into the Course entity, adhering closely to the project's specifications while maintaining the integrity of the current data model.

### Example Integrating Files

File: `api/courses.py` (new or existing file to be updated)
```python
from fastapi import APIRouter, HTTPException
from .models.courses import CourseUpdateRequest, CourseResponse
import aiosqlite

router = APIRouter()

@router.patch("/courses/{course_id}", response_model=CourseResponse)
async def update_course(course_id: int, request: CourseUpdateRequest):
    async with aiosqlite.connect("database.db") as db:
        # Logic to validate teacher assignment
        # Exceptional handling logic will be here

        result = await db.execute("UPDATE course SET teacher_id = ? WHERE id = ?", (request.teacher_id, course_id,))
        if result.rowcount == 0:
            raise HTTPException(status_code=404, detail="Course not found.")
        await db.commit()
        return await get_course_by_id(course_id)

async def get_course_by_id(course_id: int):
    async with aiosqlite.connect("database.db") as db:
        cursor = await db.execute("SELECT id, name, level, teacher_id FROM course WHERE id = ?", (course_id,))
        course = await cursor.fetchone()
        return CourseResponse(id=course[0], name=course[1], level=course[2], teacher_id=course[3])
```

This plan provides a clear roadmap for the successful integration of teacher associations with courses, ensuring all facets align with functional requirements and the existing infrastructure.