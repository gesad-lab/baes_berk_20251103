# Implementation Plan: Create Teacher Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Add Course Relationship to Student Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Create Course Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Student Entity Management Application

---

## Version: 1.0.0
## Date: 2023-10-07

## Overview
This implementation plan outlines the technical changes required to introduce a new Teacher entity into the existing educational management system. This feature will enable the management of teacher information, including their course assignments and communication capabilities with students. The plan includes modifications to the data model, related API contracts, and the implementation strategy, ensuring that existing functionalities remain unaffected.

## Architecture
The existing architecture will remain based on the FastAPI framework and SQLite for data storage. A new Teacher table will be introduced in the SQL database. The API will be updated to include endpoints for creating and listing Teacher entities.

### System Components
1. **FastAPI Application**: The application will be extended to provide endpoints for managing Teacher entities.
2. **SQLite Database**: A new table will be created to store Teacher data while preserving existing data integrity.
3. **Pydantic Models**: New models will be defined to validate Teacher data during API requests.

## Technical Stack
- **Programming Language**: Python 3.11+
- **Web Framework**: FastAPI
- **Database**: SQLite
- **Data Validation**: Pydantic
- **Documentation**: OpenAPI (Automatically generated by FastAPI)
- **Testing Framework**: pytest

## Module Boundaries and Responsibilities

### Modules
1. **API Module**
   - Provide new RESTful endpoints for creating and listing Teacher entities.
   
2. **Database Module**
   - Implement the required schema changes to add the new Teacher table.
   - Define a migration strategy to ensure existing data remains intact.
   
3. **Service Module**
   - Execute business logic for managing Teacher creation and retrieval.

## Data Model

### Teacher SQL Schema
The SQL schema for the new Teacher table is defined as follows:
```sql
CREATE TABLE teacher (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE
);
```

### Pydantic Models
```python
from pydantic import BaseModel, EmailStr, Field

class TeacherCreateRequest(BaseModel):
    """Model for creating a new teacher."""
    name: str = Field(..., min_length=1, example="John Doe")
    email: EmailStr = Field(..., example="john.doe@example.com")

class TeacherResponse(BaseModel):
    """Model for the response containing teacher details."""
    id: int
    name: str
    email: EmailStr

    class Config:
        schema_extra = {
            "example": {
                "id": 1,
                "name": "John Doe",
                "email": "john.doe@example.com"
            }
        }
```

## API Contracts

### Endpoints

1. **POST /teachers**
   - **Description**: Create a new Teacher.
   - **Request Body**:
     ```json
     {
         "name": "string",
         "email": "string"
     }
     ```
   - **Response**: 
     - **201 Created**: On successful teacher creation.
     - **400 Bad Request**: If input validation fails.
     ```json
     {
         "error": {
             "code": "E002",
             "message": "Invalid input data."
         }
     }
     ```

2. **GET /teachers**
   - **Description**: Retrieve all teachers in the system.
   - **Response**:
     ```json
     {
         "teachers": [
             {
                 "id": 1,
                 "name": "John Doe",
                 "email": "john.doe@example.com"
             },
             {
                 "id": 2,
                 "name": "Jane Smith",
                 "email": "jane.smith@example.com"
             }
         ]
     }
     ```

## Implementation Approach

### Setup
1. **Update Project Structure**: 
   - Introduce a new file `api/teachers.py` to handle Teacher-related functionalities.
   - Update `README.md` with new API documentation for Teacher endpoints.

### Development Steps
1. **Database Migration**: Implement a migration for the Teacher table using `aiosqlite`:
   ```python
   async def migrate():
       async with aiosqlite.connect("database.db") as db:
           await db.execute("""
               CREATE TABLE IF NOT EXISTS teacher (
                   id INTEGER PRIMARY KEY AUTOINCREMENT,
                   name TEXT NOT NULL,
                   email TEXT NOT NULL UNIQUE
               )
           """)
           await db.commit()
   ```

2. **API Endpoints Creation**: Define the RESTful endpoints in `api/teachers.py`:
   ```python
   from fastapi import APIRouter, HTTPException
   from .models.teachers import TeacherCreateRequest, TeacherResponse
   import aiosqlite

   router = APIRouter()

   @router.post("/teachers", response_model=TeacherResponse)
   async def create_teacher(teacher: TeacherCreateRequest):
       async with aiosqlite.connect("database.db") as db:
           cursor = await db.execute("INSERT INTO teacher (name, email) VALUES (?, ?)", 
                                      (teacher.name, teacher.email))
           await db.commit()
           teacher_id = cursor.lastrowid

           return TeacherResponse(id=teacher_id, name=teacher.name, email=teacher.email)

   @router.get("/teachers", response_model=list[TeacherResponse])
   async def list_teachers():
       async with aiosqlite.connect("database.db") as db:
           cursor = await db.execute("SELECT id, name, email FROM teacher")
           teachers = await cursor.fetchall()
           return [TeacherResponse(id=row[0], name=row[1], email=row[2]) for row in teachers]
   ```

3. **Validation and Error Handling**: Include validation to ensure the name and email are correctly formatted. Implement error handling to return appropriate messages if duplicates or validation errors occur during creation.

4. **Testing**: Create tests to ensure that the Teacher entity functionality works as expected, focusing on creation with valid/invalid data and listing teachers.

Example Test Case:
```python
def test_create_teacher_with_valid_data(client):
    response = client.post("/teachers", json={"name": "John Doe", "email": "john.doe@example.com"})
    assert response.status_code == 201  # Assuming successful creation

def test_create_teacher_with_duplicate_email(client):
    client.post("/teachers", json={"name": "John Doe", "email": "john.doe@example.com"})
    response = client.post("/teachers", json={"name": "John Smith", "email": "john.doe@example.com"})
    assert response.status_code == 400  # Duplicate email error handling
```

## Scalability Considerations
The design maintains a stateless and efficient structure that can be scaled to accommodate more Teacher-related functionalities in future iterations.

## Security Considerations
Adhere to existing security protocols to ensure sensitive data handling, specifically during API requests. Use validation to prevent SQL injection and maintain access control for the creation of Teacher records.

## Deployment Considerations
- Execute the migration strategy to create the new Teacher table, ensuring no disruptions to existing operations.
- Thoroughly verify the success of the migration before proceeding with API deployment.

## Documentation
- Update the API documentation in `README.md` to include descriptions of the new Teacher entity endpoints, detailing request/response formats.
- Provide example payloads for better clarity and developer support.

## Testing Strategy
Achieve a minimum of 70% code coverage for all new Teacher-related functionalities, particularly focusing on the creation and retrieval processes and their associated validations.

## Conclusion
This implementation plan provides a detailed approach to integrating the Teacher entity into the existing educational management system, ensuring that all specified requirements are met while maintaining the integrity of the current data model.

### Example Integrating Files
File: `api/teachers.py` (new file)
```python
from fastapi import APIRouter, HTTPException
from .models.teachers import TeacherCreateRequest, TeacherResponse
import aiosqlite

router = APIRouter()

@router.post("/teachers", response_model=TeacherResponse)
async def create_teacher(teacher: TeacherCreateRequest):
    async with aiosqlite.connect("database.db") as db:
        cursor = await db.execute("INSERT INTO teacher (name, email) VALUES (?, ?)",
                                   (teacher.name, teacher.email))
        await db.commit()
        teacher_id = cursor.lastrowid
        return TeacherResponse(id=teacher_id, name=teacher.name, email=teacher.email)

@router.get("/teachers", response_model=list[TeacherResponse])
async def list_teachers():
    async with aiosqlite.connect("database.db") as db:
        cursor = await db.execute("SELECT id, name, email FROM teacher")
        teachers = await cursor.fetchall()
        return [TeacherResponse(id=row[0], name=row[1], email=row[2]) for row in teachers]
```

File: `api/models/teachers.py` (new file)
```python
from pydantic import BaseModel, EmailStr, Field

class TeacherCreateRequest(BaseModel):
    """Model for creating a new teacher."""
    name: str = Field(..., min_length=1, example="John Doe")
    email: EmailStr = Field(..., example="john.doe@example.com")

class TeacherResponse(BaseModel):
    """Model for the response containing teacher details."""
    id: int
    name: str
    email: EmailStr

    class Config:
        schema_extra = {
            "example": {
                "id": 1,
                "name": "John Doe",
                "email": "john.doe@example.com"
            }
        }
```

File: `tests/api/test_teachers.py` (new file)
```python
import pytest
from fastapi.testclient import TestClient
from api.teachers import app  # Assuming the FastAPI app is defined in api/teachers.py

client = TestClient(app)

def test_create_teacher_with_valid_data():
    response = client.post("/teachers", json={"name": "John Doe", "email": "john.doe@example.com"})
    assert response.status_code == 201

def test_create_teacher_with_invalid_email():
    response = client.post("/teachers", json={"name": "Jane Doe", "email": "jane.doe"})
    assert response.status_code == 400  # Invalid email format
```

This plan meticulously details the implementation of the Teacher entity, ensuring compliance with the project's specifications while addressing data integrity and system architecture.