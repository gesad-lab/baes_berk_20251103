# Implementation Plan: Add Course Relationship to Student Entity

---

## I. Project Overview

This implementation plan outlines the integration of a course relationship into the existing Student Entity Web Application. The goal is to facilitate students' ability to be associated with multiple courses, laying the foundation for future course enrollment functionalities and improved academic tracking. This plan details the necessary architectural components, API endpoints, database schema modifications, and testing strategies to ensure functional requirements are met, and backward compatibility with existing functionalities is maintained.

## II. Technical Architecture

### 1. Architectural Style
- The existing microservices architecture will be continued, allowing for the addition of relationships between the Student and Course entities.

### 2. Technology Stack
- **Programming Language**: Python 3.11+
- **Web Framework**: FastAPI
- **Database**: SQLite
- **ORM**: SQLAlchemy
- **Testing Framework**: pytest
- **Documentation**: OpenAPI (auto-generated by FastAPI)
- **Environment Management**: `venv` for virtual environments

## III. Module Design

### 1. Module Boundaries
- **Student Model Update**: `src/models/student.py`: Update the existing Student model to include a relationship reference to courses.
- **Course Model**: `src/models/course.py`: Add a new Course model to represent the Course entity.
- **Course API**: `src/routes/course.py`: Develop API endpoints for associating students with courses and retrieving associated courses.
- **Database Configuration**: `src/database.py`: Manage database migrations and relationships.
- **Input Validation**: `src/validators.py`: Validate inputs for course associations.

### 2. Responsibilities
- **Student Model**: Represents student data and their relationships with courses.
- **Course Model**: Handles CRUD operations for course data (name and level).
- **Course API**: Handles HTTP requests for course associations and retrieval.
- **Database Configuration**: Ensures migrations maintain data integrity and relationships.
- **Input Validation**: Validates incoming data for associations.

### 3. Data Models
```python
# src/models/student.py

from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Student(Base):
    __tablename__ = 'students'

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    # Adding a relationship with courses
    courses = relationship("Course", secondary="student_courses")

class StudentCourse(Base):
    __tablename__ = 'student_courses'  # New association table for many-to-many relationship
    student_id = Column(Integer, ForeignKey('students.id'), primary_key=True)
    course_id = Column(Integer, ForeignKey('courses.id'), primary_key=True)

# src/models/course.py

from sqlalchemy import Column, String, Integer
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Course(Base):
    __tablename__ = 'courses'
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    level = Column(String, nullable=False)
```

## IV. Database Design

### 1. Schema Update and Migration
- New association table `student_courses` for many-to-many relationships between Students and Courses will be created, preserving existing data.

**Migration strategy**:
- Create an Alembic migration that adds the `student_courses` table and `courses` table while ensuring data integrity:
```python
# migrations/versions/xxxx_create_student_course_relationship.py

"""Create student_courses association table

Revision ID: xxxx
Revises: (last revision)
Create Date: (create date)
"""

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = 'xxxx'
down_revision = None
branch_labels = None
depends_on = None

def upgrade() -> None:
    op.create_table(
        'student_courses',
        sa.Column('student_id', sa.Integer(), sa.ForeignKey('students.id'), primary_key=True),
        sa.Column('course_id', sa.Integer(), sa.ForeignKey('courses.id'), primary_key=True),
    )

def downgrade() -> None:
    op.drop_table('student_courses')
```

### 2. Automatic Database Schema Creation
- Ensure the `init_db` function in `src/database.py` initializes the database and runs migrations if they haven't been applied yet.

```python
# src/database.py

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from alembic import command
from alembic.config import Config

DATABASE_URL = "sqlite:///./database.db"

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def init_db():
    from models.course import Base as CourseBase # Include Course model
    from models.student import Base as StudentBase # Include updated Student model
    StudentBase.metadata.create_all(bind=engine)  # Create all tables, including newly added ones
    CourseBase.metadata.create_all(bind=engine)  # Tables related to Course
    alembic_cfg = Config("alembic.ini")
    command.upgrade(alembic_cfg, "head")  # Run migrations if available
```

## V. API Design

### 1. Endpoints
- **POST /students/{student_id}/courses**: To associate a Student with a Course.
  - **Request Body**:
    ```json
    {
      "course_id": 1
    }
    ```
  - **Responses**:
    - **200 OK**: 
      ```json
      {
        "student_id": 1,
        "course_id": 1
      }
      ```
    - **404 Not Found** for non-existent Student or Course: 
      ```json
      {
        "error": {
          "code": "E001",
          "message": "Student or Course not found."
        }
      }
      ```

- **GET /students/{student_id}/courses**: To retrieve all Courses associated with a specific Student.
  - **Responses**:
    - **200 OK**: 
      ```json
      [
        {
          "id": 1,
          "name": "Introduction to Programming",
          "level": "Beginner"
        }
      ]
      ```
    - **204 No Content**: Indicating no courses are associated with that student.

### 2. Error Handling
- Implement error handling in the API to appropriately manage and respond to invalid requests, such as associating non-existent students or courses.

## VI. Testing Strategy

### 1. Test Coverage
- Introduce automated tests to ensure complete coverage of student-course association functionalities, targeting 75% overall coverage with a focus on validating the association logic.

### 2. Test Types
- **Unit tests**: For the functionalities related to associating students with courses.
- **Integration tests**: To validate the retrieval of associated courses and interactions with the SQLite database.

### 3. Test Organization
- Organize new tests to mirror the structure of existing tests:
  - Source Code: `src/`
  - Tests: `tests/`
    - For course API: `tests/test_student_course.py`

### 4. Example Unit Test
```python
# tests/test_student_course.py

def test_associate_student_with_course(client):
    response = client.post("/students/1/courses", json={"course_id": 1})
    assert response.status_code == 200
    assert response.json()["student_id"] == 1
    assert response.json()["course_id"] == 1

def test_associate_nonexistent_student(client):
    response = client.post("/students/999/courses", json={"course_id": 1})
    assert response.status_code == 404
    assert response.json()["error"]["code"] == "E001"  # Student not found

def test_get_courses_for_student(client):
    response = client.get("/students/1/courses")
    assert response.status_code == 200
    assert isinstance(response.json(), list)  # Check structure
```

## VII. Configuration Management

### 1. Environment Variables
- Document any new required environment variables for setups, such as database configuration.

### 2. Sensible Defaults
- Ensure configurations provide reasonable defaults and preserve backward compatibility with existing operations.

## VIII. Logging & Monitoring

- Implement structured logging for the operations related to student-course associations.
```python
# In the API route implementation
import logging

logger = logging.getLogger("student_course_api")

# Logging example
logger.info("Associating student: %s with course: %s", student_id, course_id)
```

## IX. Success Criteria Verification

- Validate the successful implementation of associating students with courses by ensuring:
  1. The association endpoint returns a 200 status upon successful association.
  2. The course retrieval endpoint operates correctly, returning a 200 status with the expected structured JSON response.
  3. The validation logic accurately returns 404 errors for invalid associations.

This plan provides a comprehensive approach to adding a course relationship to the Student Entity, ensuring alignment with the specified requirements while maintaining the application's robustness.