# Implementation Plan: Create Teacher Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Add Course Relationship to Student Entity

---

## I. Project Overview

This implementation plan outlines the integration of a new entity, "Teacher," into the existing Educational Management System. The goal is to facilitate the storage and management of teacher information, enhancing operations related to class assignments, evaluations, and communications. This plan details the necessary architectural components, API endpoints, database schema modifications, and testing strategies to ensure functional requirements are met while maintaining backward compatibility.

## II. Technical Architecture

### 1. Architectural Style
- The existing microservices architecture will be enhanced by introducing the Teacher entity, utilizing the same structural design as the previously implemented entities (Student and Course).

### 2. Technology Stack
- **Programming Language**: Python 3.11+
- **Web Framework**: FastAPI
- **Database**: SQLite
- **ORM**: SQLAlchemy
- **Testing Framework**: pytest
- **Documentation**: OpenAPI (auto-generated by FastAPI)
- **Environment Management**: `venv` for virtual environments

## III. Module Design

### 1. Module Boundaries
- **Teacher Model**: `src/models/teacher.py`: Create a new Teacher model to represent the Teacher entity.
- **Teacher API**: `src/routes/teacher.py`: Develop API endpoints for creating and retrieving Teacher entities.
- **Database Configuration**: Extend existing database configuration to include Teacher model migrations.
- **Input Validation**: Ensure proper input validation for teacher creation.

### 2. Responsibilities
- **Teacher Model**: Represents teacher data (name and email).
- **Teacher API**: Handles HTTP requests for teacher creation and retrieval operations.
- **Database Configuration**: Manages migrations to introduce the Teacher table.
- **Input Validation**: Validates incoming data for teacher creation.

### 3. Data Models
```python
# src/models/teacher.py

from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Teacher(Base):
    __tablename__ = 'teachers'
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, nullable=False)
```

## IV. Database Design

### 1. Schema Update and Migration
- Create a new `teachers` table to store Teacher records while preserving existing data in the Student and Course tables.

**Migration Strategy**:
- Create an Alembic migration that adds the `teachers` table.
```python
# migrations/versions/xxxx_create_teachers_table.py

"""Create teachers table

Revision ID: xxxx
Revises: (previous revision)
Create Date: (create date)
"""

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = 'xxxx'
down_revision = None
branch_labels = None
depends_on = None

def upgrade() -> None:
    op.create_table(
        'teachers',
        sa.Column('id', sa.Integer(), primary_key=True),
        sa.Column('name', sa.String(), nullable=False),
        sa.Column('email', sa.String(), nullable=False)
    )

def downgrade() -> None:
    op.drop_table('teachers')
```

### 2. Automatic Database Schema Creation
- Ensure the `init_db` function in `src/database.py` initializes the database and runs migrations if they haven't been applied yet.

```python
# src/database.py

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from alembic import command
from alembic.config import Config
from models.teacher import Base as TeacherBase  # Include Teacher model

DATABASE_URL = "sqlite:///./database.db"

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def init_db():
    from models.student import Base as StudentBase  # Include updated Student model
    from models.course import Base as CourseBase  # Include updated Course model
    StudentBase.metadata.create_all(bind=engine)
    CourseBase.metadata.create_all(bind=engine)
    TeacherBase.metadata.create_all(bind=engine)  # Create Teacher table
    alembic_cfg = Config("alembic.ini")
    command.upgrade(alembic_cfg, "head")  # Run migrations
```

## V. API Design

### 1. Endpoints
- **POST /teachers**: To create a new Teacher entity.
  - **Request Body**:
    ```json
    {
      "name": "John Doe",
      "email": "john.doe@example.com"
    }
    ```
  - **Responses**:
    - **201 Created**: 
      ```json
      {
        "id": 1,
        "name": "John Doe",
        "email": "john.doe@example.com"
      }
      ```
    - **400 Bad Request** when fields are missing:
      ```json
      {
        "error": {
          "code": "E001",
          "message": "Name and email are required."
        }
      }
      ```

- **GET /teachers/{teacher_id}**: To retrieve the details of a specific Teacher entity by ID.
  - **Responses**:
    - **200 OK**: 
      ```json
      {
        "id": 1,
        "name": "John Doe",
        "email": "john.doe@example.com"
      }
      ```
    - **404 Not Found** if the Teacher does not exist.

### 2. Error Handling
- Implement error handling in the API endpoint to provide clear validation feedback when creation requests are invalid, such as missing name or email.

## VI. Testing Strategy

### 1. Test Coverage
- Introduce automated tests to ensure adequate coverage for the Teacher functionalities, targeting 70% coverage with a focus on validation and creation logic.

### 2. Test Types
- **Unit tests**: For the functionalities related to teacher creation and retrieval.
- **Integration tests**: To validate the RESTful API functionalities with the SQLite database.

### 3. Test Organization
- Organize new tests to mirror the structure of existing tests:
  - Source Code: `src/`
  - Tests: `tests/`
    - For teacher API: `tests/test_teacher.py`

### 4. Example Unit Test
```python
# tests/test_teacher.py

def test_create_teacher(client):
    response = client.post("/teachers", json={"name": "John Doe", "email": "john.doe@example.com"})
    assert response.status_code == 201
    assert response.json()["name"] == "John Doe"
    assert response.json()["email"] == "john.doe@example.com"

def test_create_teacher_with_missing_fields(client):
    response = client.post("/teachers", json={"name": "", "email": "noemail@example.com"})
    assert response.status_code == 400
    assert response.json()["error"]["code"] == "E001"  # Validation error for required fields

def test_get_teacher(client):
    # Assuming a teacher with id=1 exists
    response = client.get("/teachers/1")
    assert response.status_code == 200
    assert response.json()["id"] == 1
```

## VII. Configuration Management

### 1. Environment Variables
- Document any new required environment variables for setups, particularly related to database configuration.

### 2. Sensible Defaults
- Ensure configurations provide sensible defaults so that the application can run locally without extensive setup.

## VIII. Logging & Monitoring

- Implement structured logging for the teacher entity operations.
```python
# In the API route implementation
import logging

logger = logging.getLogger("teacher_api")

# Logging example
logger.info("Creating a new teacher: %s", name)
```

## IX. Success Criteria Verification

- Validate that the following conditions are successfully implemented:
  1. The API endpoint for creating a Teacher returns a 201 status with the correct information.
  2. The system returns a 400 Bad Request status when required fields are missing.
  3. A valid GET request retrieves the correct teacher information with a 200 OK status, confirming data integrity.

This plan provides a comprehensive approach to introducing the Teacher entity within the existing system, ensuring alignment with the specified requirements while maintaining robustness and backward compatibility with the current database structure.