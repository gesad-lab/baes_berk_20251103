# Implementation Plan: Create Course Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Email Field in Student Entity

---
## I. Project Overview

This implementation plan outlines the addition of a new Course entity to the existing Student Entity Web Application. The goal is to facilitate better organization and management of courses by introducing a Course entity with a name and level attribute. The implementation details the new architecture components, API endpoints, database schema modifications, and testing strategies to ensure functional requirements are met and backward compatibility with existing functionalities is maintained.

## II. Technical Architecture

### 1. Architectural Style
- The existing microservices architecture will be continued, allowing for the addition of the Course entity alongside the Student entity.

### 2. Technology Stack
- **Programming Language**: Python 3.11+
- **Web Framework**: FastAPI
- **Database**: SQLite
- **ORM**: SQLAlchemy
- **Testing Framework**: pytest
- **Documentation**: OpenAPI (auto-generated by FastAPI)
- **Environment Management**: `venv` for virtual environments

## III. Module Design

### 1. Module Boundaries
- **Course Model** `src/models/course.py`: Creation of a new Course model to represent the Course entity with name and level attributes.
- **Course API** `src/routes/course.py`: Development of API endpoints for creating and retrieving courses.
- **Database Configuration** `src/database.py`: Inclusion of migrations for the new Course table.
- **Input Validation** `src/validators.py`: Creation of validators to check for required fields in course creation.

### 2. Responsibilities
- **Course Model**: Represents course data (name and level), handling CRUD operations.
- **Course API**: Handles HTTP requests for creating and retrieving courses.
- **Database Configuration**: Manages database migration to add the Course table.
- **Input Validation**: Checks for mandatory presence of name and level fields during course creation.

### 3. Data Models
```python
# src/models/course.py

from sqlalchemy import Column, String, Integer
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Course(Base):
    __tablename__ = 'courses'
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    level = Column(String, nullable=False)
```

## IV. Database Design

### 1. Schema Update and Migration
- A new `courses` table will be created with `name` and `level` fields, both set as required strings. Existing student data will be preserved during this addition.

**Migration strategy**:
- Create an Alembic migration that introduces the courses table while ensuring data integrity:
```python
# migrations/versions/xxxx_create_courses_table.py

"""Create courses table

Revision ID: xxxx
Revises: (no previous revision)
Create Date: (create date)
"""

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = 'xxxx'
down_revision = None
branch_labels = None
depends_on = None

def upgrade() -> None:
    op.create_table(
        'courses',
        sa.Column('id', sa.Integer(), primary_key=True),
        sa.Column('name', sa.String(), nullable=False),
        sa.Column('level', sa.String(), nullable=False),
    )

def downgrade() -> None:
    op.drop_table('courses')
```

### 2. Automatic Database Schema Creation
- Ensure the `init_db` function in `src/database.py` initializes the database and runs the migrations if they haven't been applied yet.

```python
# src/database.py

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models.course import Base  # New import for Course model
from alembic import command
from alembic.config import Config

DATABASE_URL = "sqlite:///./courses.db"

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def init_db():
    Base.metadata.create_all(bind=engine)  # Create all tables, including newly added ones
    alembic_cfg = Config("alembic.ini")
    command.upgrade(alembic_cfg, "head")  # Run migrations if available
```

## V. API Design

### 1. Endpoints
- **POST /courses**: To create a new course.
  - **Request Body**:
    ```json
    {
      "name": "Introduction to Programming",
      "level": "Beginner"
    }
    ```
  - **Responses**:
    - **201 Created**: 
      ```json
      {
        "id": 1,
        "name": "Introduction to Programming",
        "level": "Beginner"
      }
      ```
    - **400 Bad Request** (missing name):
      ```json
      {
        "error": {
          "code": "E001",
          "message": "Name is required."
        }
      }
      ```
    - **400 Bad Request** (missing level):
      ```json
      {
        "error": {
          "code": "E002",
          "message": "Level is required."
        }
      }
      ```

- **GET /courses**: To retrieve all courses.
  - **Responses**:
    - **200 OK**: 
      ```json
      [
        {
          "id": 1,
          "name": "Introduction to Programming",
          "level": "Beginner"
        }
      ]
      ```

### 2. Error Handling
- Implement error handling in the API to appropriately manage and respond to validation errors concerning required fields.

## VI. Testing Strategy

### 1. Test Coverage
- Introduce automated tests to ensure complete coverage of course functionalities, targeting 70% overall coverage with a focus on validating course creation and retrieval scenarios.

### 2. Test Types
- **Unit tests**: For the functionalities related to course creation and retrieval.
- **Integration tests**: To validate the interaction between the Course model and the SQLite database.

### 3. Test Organization
- Organize new tests to mirror the structure of existing tests:
  - Source Code: `src/`
  - Tests: `tests/`
    - For course API: `tests/test_course.py`

### 4. Example Unit Test
```python
# tests/test_course.py

def test_create_course(client):
    response = client.post("/courses", json={"name": "Introduction to Programming", "level": "Beginner"})
    assert response.status_code == 201
    assert response.json()["name"] == "Introduction to Programming"
    assert response.json()["level"] == "Beginner"

def test_create_course_missing_name(client):
    response = client.post("/courses", json={"level": "Beginner"})
    assert response.status_code == 400
    assert response.json()["error"]["code"] == "E001"  # Name is required

def test_create_course_missing_level(client):
    response = client.post("/courses", json={"name": "Introduction to Programming"})
    assert response.status_code == 400
    assert response.json()["error"]["code"] == "E002"  # Level is required
```

## VII. Configuration Management

### 1. Environment Variables
- Ensure documentations of any new required environment variables for the setup that may affect course logic and any database configurations remain compatible.

### 2. Sensible Defaults
- Provide sensible configurations while preserving backward compatibility with existing operations.

## VIII. Logging & Monitoring

- Implement structured logging for the operations related to courses, including logging invalid input requests and logging successful course creations.

```python
# In the API route implementation
import logging

logger = logging.getLogger("course_api")

# Logging example
logger.info("Creating course: %s, Level: %s", course.name, course.level)
```

## IX. Success Criteria Verification

- Validate the successful implementation of the Course entity through:
  1. The endpoint for course creation outputs a 201 status including name and level.
  2. The course retrieval endpoint operates correctly, returning a 200 status with the expected structured JSON response.
  3. The validation logic accurately returns 400 errors for missing name and level inputs.
  4. The database migration to add the Course table seamlessly coexists with existing Student data and workflows.

By executing the above plan, the Student Entity Web Application will adeptly incorporate the new Course entity, ensuring adherence to the specifications while maintaining robustness in functionalities, error handling, and integrations with previously existing structures.