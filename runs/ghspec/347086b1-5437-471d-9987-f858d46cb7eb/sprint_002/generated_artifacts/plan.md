# Implementation Plan: Email Field in Student Entity

---
## I. Project Overview

Building upon the existing Student Entity Web Application, this implementation plan outlines the addition of an email field within the Student entity. The goal is to enhance the student profile with an email, facilitating future integrations and data management. The plan details the new architecture components, API endpoints, database schema modifications, and testing strategies to meet the specified requirements while ensuring backward compatibility.

## II. Technical Architecture

### 1. Architectural Style
- The microservices architecture will be retained, continuing with a single service managing the Student entity.

### 2. Technology Stack
- **Programming Language**: Python 3.11+
- **Web Framework**: FastAPI
- **Database**: SQLite
- **ORM**: SQLAlchemy
- **Testing Framework**: pytest
- **Documentation**: OpenAPI (auto-generated by FastAPI)
- **Environment Management**: `venv` for virtual environments

## III. Module Design

### 1. Module Boundaries
- **Student Model** `src/models/student.py`: Update the existing Student model to include the email field.
- **Student API** `src/routes/student.py`: Extend API endpoints for creating and retrieving students to accommodate the new email field.
- **Database Configuration** `src/database.py`: Ensure that migrations are handled for the new email field addition.
- **Input Validation** `src/validators.py`: Modify input validation to check for valid email format and mandatory presence.

### 2. Responsibilities
- **Student Model**: Now represents student data with the newly added email field, handling CRUD operations.
- **Student API**: Updates existing routes to include functionality for handling the email field.
- **Database Configuration**: Manages database migration for schema updates.
- **Input Validation**: Checks for a valid email format and that the email field is required during student creation.

### 3. Data Models
```python
# src/models/student.py

from sqlalchemy import Column, String, Integer
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Student(Base):
    __tablename__ = 'students'
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, nullable=True)  # new field added
```

## IV. Database Design

### 1. Schema Update and Migration
- The existing `students` table will be updated to include the `email` field. The migration will be crafted to preserve existing data.

**Migration strategy**:
- Create an Alembic migration that adds the email column with nullable set to True and ensure that existing records are untouched. The migration will be as follows:
```python
# migrations/versions/xxxx_add_email_field.py

"""Add email field to students table

Revision ID: xxxx
Revises: (previous revision)
Create Date: (create date)
"""

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = 'xxxx'
down_revision = None
branch_labels = None
depends_on = None

def upgrade() -> None:
    op.add_column('students', sa.Column('email', sa.String(), nullable=True))

def downgrade() -> None:
    op.drop_column('students', 'email')
```

### 2. Automatic Database Schema Creation
- Update the `init_db` function in `src/database.py` to run migrations on startup if they aren't applied yet. 

```python
# src/database.py

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models.student import Base
from alembic import command
from alembic.config import Config

DATABASE_URL = "sqlite:///./students.db"

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def init_db():
    Base.metadata.create_all(bind=engine)
    alembic_cfg = Config("alembic.ini")
    command.upgrade(alembic_cfg, "head")  # Run migrations if available
```

## V. API Design

### 1. Endpoints
- **POST /students**: To create a new student with email.
  - **Request Body**:
    ```json
    {
      "name": "John Doe",
      "email": "john.doe@example.com"
    }
    ```
  - **Responses**:
    - **201 Created**: 
      ```json
      {
        "id": 1,
        "name": "John Doe",
        "email": "john.doe@example.com"
      }
      ```
    - **400 Bad Request** (missing email):
      ```json
      {
        "error": {
          "code": "E002",
          "message": "Email is required."
        }
      }
      ```
    - **400 Bad Request** (invalid email):
      ```json
      {
        "error": {
          "code": "E003",
          "message": "Invalid email format."
        }
      }
      ```

- **GET /students**: To retrieve all students.
  - **Responses**:
    - **200 OK**: 
      ```json
      [
        {
          "id": 1,
          "name": "John Doe",
          "email": "john.doe@example.com"
        }
      ]
      ```

### 2. Error Handling
- Modify error handling in the API to catch and respond with structured JSON for email validation errors as well as any other potential input validation issues.

## VI. Testing Strategy

### 1. Test Coverage
- Extend test coverage to ensure email scenarios are handled properly, aiming for 70% coverage on business logic.

### 2. Test Types
- **Unit tests**: For the updated student creation and retrieval functionalities.
- **Integration tests**: To test the modifications with the SQLite database to ensure seamless operations.

### 3. Test Organization
- Ensure the new tests are organized similarly to existing ones:
  - Source Code: `src/`
  - Tests: `tests/`
    - For student API: `tests/test_student.py`

### 4. Example Unit Test
```python
# tests/test_student.py

def test_create_student_with_email(client):
    response = client.post("/students", json={"name": "John Doe", "email": "john.doe@example.com"})
    assert response.status_code == 201
    assert response.json()["email"] == "john.doe@example.com"

def test_create_student_missing_email(client):
    response = client.post("/students", json={"name": "John Doe"})
    assert response.status_code == 400
    assert response.json()["error"]["code"] == "E002"  # Email is required

def test_create_student_invalid_email(client):
    response = client.post("/students", json={"name": "John Doe", "email": "not-an-email"})
    assert response.status_code == 400
    assert response.json()["error"]["code"] == "E003"  # Invalid email format
```

## VII. Configuration Management

### 1. Environment Variables
- Ensure the existing `.env` configuration remains compatible and document any new required environment variables.

### 2. Sensible Defaults
- Maintain sensible defaults for the new email field allowing existing operations to function without necessitating changes.

## VIII. Logging & Monitoring

- Continue using structured logging for creating and managing the email field updates, logging unacceptable inputs, and successful student creations.

```python
# In the API route implementation
import logging

logger = logging.getLogger("student_api")

# Logging example
logger.info("Creating student: %s, Email: %s", student.name, student.email)
```

## IX. Success Criteria Verification

- The application must be successfully tested to ensure:
  1. Successful student creation returns a 201 status with both name and email.
  2. Retrieval API works correctly and returns a 200 status with the expected JSON array structure, including emails.
  3. Invalid and missing email input correctly returns appropriate 400 error messages.
  4. The database migration occurs smoothly without impacting existing records or functionality.

By implementing the above plan, the Student Entity Web Application will efficiently integrate the new email field while adhering to the specifications and maintaining robust functionalities and error handling mechanisms.