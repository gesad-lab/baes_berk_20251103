# Implementation Plan: Create Course Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Add Email Field to Student Entity

## Version: 1.0.0  
**Purpose**: To outline the technical architecture, technology stack, implementation approach, and module design for adding a new Course Entity to the existing system.

---

## I. Project Architecture

### 1.1 Application Design
The new Course entity will be integrated into the existing microservices architecture, enhancing the capability for managing courses effectively within the current system framework. FastAPI continues to serve as the backbone framework, ensuring seamless integration and functionality while maintaining consistency.

### 1.2 Technology Stack
- **Backend Framework**: FastAPI (Python 3.11+)
- **Database**: SQLite
- **Data Access Layer**: SQLAlchemy for ORM
- **API Documentation**: Swagger (automatically generated by FastAPI)
- **Testing Framework**: pytest
- **Environment Variables**: python-dotenv for configuration management

---

## II. Module Design

### 2.1 Module Responsibilities
- **Course Management Module**
  - Introduce a new Course entity that includes the required fields: `name` and `level`.
  - Validate that both fields are provided during course creation.
  - Support API endpoint for creating and retrieving course records.

### 2.2 Component Breakdown
- **API Endpoints**
  - `POST /courses`: Endpoint to create a new course record with validation for required fields.
  - `GET /courses/{id}`: Endpoint to retrieve course details including `name` and `level`.
- **Database Model**
  - **Course**
    - Attributes:
      - `id`: Integer (auto-incremented)
      - `name`: String (required)
      - `level`: String (required)

---

## III. Data Model

### 3.1 Course Model Definition
```python
from sqlalchemy import Column, Integer, String
from database import Base  # Assuming a file named database.py for SQLAlchemy setup

class Course(Base):
    """Model representing a course in the system."""
    __tablename__ = 'courses'

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    level = Column(String, nullable=False)

    def __repr__(self):
        """Provide a string representation of the course object."""
        return f"<Course(id={self.id}, name='{self.name}', level='{self.level}')>"
```

### 3.2 API Requests and Responses

#### 3.2.1 Create a Course
- **Request** (POST /courses)
  - **Body**:
    ```json
    {
      "name": "Python Programming",
      "level": "Beginner"
    }
    ```
- **Response** (201 Created)
  - **Body**:
    ```json
    {
      "id": 1,
      "name": "Python Programming",
      "level": "Beginner",
      "message": "Course created successfully."
    }
    ```

#### 3.2.2 Retrieve a Course
- **Request** (GET /courses/{id})
- **Response** (200 OK)
  - **Body**:
    ```json
    {
      "id": 1,
      "name": "Python Programming",
      "level": "Beginner"
    }
    ```

---

## IV. API Error Handling

### 4.1 Common Error Responses
- **Validation Error** (400 Bad Request)
  - **Response**:
    ```json
    {
      "error": {
        "code": "E001",
        "message": "Name and level are required.",
        "details": {}
      }
    }
    ```

### 4.2 Successful Error Logging
All errors will be logged with sufficient context to enable debugging while avoiding exposure of sensitive information.

---

## V. Testing Strategy

### 5.1 Test Cases
**Create Course**: Validate API will respond correctly to valid and invalid requests.

#### Sample Test Cases
- **Test creating a course with valid name and level**
- **Test creating a course without a name or level** (expect validation error)
- **Test retrieving a course that does not exist** (expect 404)

### 5.2 Testing Framework
- Use `pytest` for structuring tests.
- Use `httpx` for making requests to the FastAPI application in tests.

---

## VI. Implementation Steps

1. **Project Setup**
   - Ensure the existing Python project structure remains intact.
   - Update the virtual environment with any new packages if required.

2. **Database Schema Update**
   - Introduce a new `courses` table in the SQLite database.
   - Create and run a migration script to add the new table without affecting existing data in the `students` table.

#### Migration Strategy
```python
from sqlalchemy import create_engine, Column, String, Integer
from sqlalchemy.orm import sessionmaker
from models.course import Course  # Importing course model

engine = create_engine("sqlite:///./students.db")
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def upgrade():
    """Create courses table."""
    from sqlalchemy import MetaData
    meta = MetaData(bind=engine)

    with engine.connect() as connection:
        connection.execute(
            """
            CREATE TABLE courses (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                level TEXT NOT NULL
            );
            """
        )
        
def downgrade():
    """Drop courses table."""
    with engine.connect() as connection:
        connection.execute("DROP TABLE IF EXISTS courses;")

if __name__ == "__main__":
    upgrade()
```

3. **API Endpoint Development**
   - Develop the `POST /courses` endpoint to handle course creation.
   - Develop the `GET /courses/{id}` endpoint to retrieve course details.

4. **Input Validation & Error Handling**
   - Implement input validations for `name` and `level` fields, ensuring they are not empty.
   - Set up structured error responses.

5. **Testing**
   - Write unit tests specifically for the course creation and retrieval functionalities.
   - Validate both successful and failure scenarios for creating courses.

6. **Documentation**
   - Utilize FastAPI's built-in documentation to provide an interactive API documentation interface for users that reflects the added functionality.

---

## VII. Deployment Considerations

### 7.1 Environment Configuration
- Use `dotenv` to read environment configurations, making it easy to manage settings across different environments (development, testing, production).

### 7.2 Production Readiness
- Ensure that health check endpoints are available.
- Graceful shutdown of the application on deployment environments.

---

## VIII. Version Control Practices

### 8.1 Git Hygiene
- Use clear commit messages that explain why changes were made.
- Follow the established project structure closely to ensure organization.

---

## IX. Conclusion

This implementation plan outlines a structured approach to enhancing the system by introducing a Course entity to manage course records effectively. The outlined architecture, module responsibilities, and testing strategy aim to ensure robust, scalable, and maintainable enhancements while adhering to existing data models. Following the provided coding standards and principles will help maintain code quality and ensure a smooth development process.

### Existing Code Files Modifications:
1. Create new file: `models/course.py` for the Course model definition.
2. Update `api/errors.py` to handle new error cases.
3. Create new file: `api/course.py` for new API endpoints related to Course management.

### Existing Code Files:
File: tests/test_course.py
```python
import pytest
from fastapi import FastAPI
from httpx import AsyncClient

# Import your FastAPI app, replace `my_app` with the correct import
from src.main import app  

@pytest.mark.asyncio
async def test_create_course():
    """Test creating a new course with valid data."""
    async with AsyncClient(app=app, base_url="http://test") as client:
        # Test case with valid course data
        response = await client.post("/courses", json={"name": "Python Programming", "level": "Beginner"})
    
    assert response.status_code == 201
    assert response.json()["name"] == "Python Programming"
    assert response.json()["level"] == "Beginner"

@pytest.mark.asyncio
async def test_create_course_missing_fields():
    """Test creating a course without required fields."""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post("/courses", json={"name": ""})
    
    assert response.status_code == 400
    assert response.json()["error"]["code"] == "E001"
```

This implementation plan details the necessary steps and considerations to successfully implement the new Course entity within the existing system while maintaining adherence to the previously established tech stack.