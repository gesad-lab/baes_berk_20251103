# Implementation Plan: Add Teacher Relationship to Course Entity

---

## INCREMENTAL DEVELOPMENT CONTEXT

### Previous Sprint Plan:
# Implementation Plan: Create Teacher Entity

---

## INCREMENTAL DEVELOPMENT CONTEXT

### Previous Sprint Plan:
# Implementation Plan: Add Course Relationship to Student Entity

---

## INCREMENTAL DEVELOPMENT CONTEXT

### Previous Sprint Plan:
# Implementation Plan: Create Course Entity

---

## INCREMENTAL DEVELOPMENT CONTEXT

### Previous Sprint Plan:
# Implementation Plan: Add Email Field to Student Entity

## Version: 1.0.0  
**Purpose**: To outline the technical architecture, technology stack, implementation approach, and module design for establishing a relationship between Course and Teacher entities within the existing system.

---

## I. Project Architecture

### 1.1 Application Design
This implementation builds upon the existing microservices architecture. We will enhance the relationship between the Course and Teacher entities using FastAPI for the backend, SQLAlchemy for database management, and adhering to current data models while ensuring backward compatibility.

### 1.2 Technology Stack
- **Backend Framework**: FastAPI (Python 3.11+)
- **Database**: SQLite or PostgreSQL depending on the current operational setup
- **Data Access Layer**: SQLAlchemy for ORM
- **API Documentation**: Swagger (automatically generated by FastAPI)
- **Testing Framework**: pytest
- **Environment Management**: python-dotenv for configuration management

---

## II. Module Design

### 2.1 Module Responsibilities
- **Course Management Module**
  - Update the Course entity to include a foreign key reference to the Teacher entity.

### 2.2 Component Breakdown
- **API Endpoints**
  - `POST /courses/{course_id}/assign-teacher`: Assign a Teacher to a Course.
  - `GET /courses/{course_id}`: Retrieve details for a specific Course, including assigned Teacher.

---

## III. Database Migration Strategy

### 3.1 Schema Update
- Modify the existing Course table to add the `teacher_id` foreign key:
  
#### Migration Script
```python
from sqlalchemy import create_engine, Column, Integer, ForeignKey
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import MetaData

DATABASE_URL = "sqlite:///./database.db"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

class Course(Base):
    __tablename__ = 'courses'
    id = Column(Integer, primary_key=True)
    teacher_id = Column(Integer, ForeignKey('teachers.id'), nullable=True)  # Add teacher_id foreign key

def upgrade():
    """Add teacher_id to the courses table."""
    with engine.connect() as conn:
        conn.execute("ALTER TABLE courses ADD COLUMN teacher_id INTEGER;")

def downgrade():
    """Remove teacher_id from the courses table."""
    with engine.connect() as conn:
        conn.execute("ALTER TABLE courses DROP COLUMN teacher_id;")  # Adjust based on your DB dialect

if __name__ == "__main__":
    upgrade()
```

---

## IV. API Design

### 4.1 API Endpoints

#### 4.1.1 Assign a Teacher to a Course
- **Request** (POST /courses/{course_id}/assign-teacher)
  - **Body**:
    ```json
    {
      "teacher_id": 1
    }
    ```
- **Response** (200 OK)
  - **Body**:
    ```json
    {
      "message": "Teacher successfully assigned to the Course."
    }
    ```

#### 4.1.2 Retrieve Course Details
- **Request** (GET /courses/{course_id})
- **Response** (200 OK)
  - **Body**:
    ```json
    {
      "id": 1,
      "name": "Mathematics",
      "teacher": {
        "id": 1,
        "name": "John Doe",
        "email": "john.doe@example.com"
      }
    }
    ```

### 4.2 Error Handling

#### 4.2.1 Common Error Responses
- **Course Not Found** (404 Not Found)
  - **Response**:
    ```json
    {
      "error": {
        "code": "E001",
        "message": "Course not found."
      }
    }
    ```

- **Teacher Assignment Conflict** (400 Bad Request)
  - **Response**:
    ```json
    {
      "error": {
        "code": "E002",
        "message": "A Teacher is already assigned to this Course."
      }
    }
    ```

- **Invalid Course ID** (400 Bad Request)
  - **Response**:
    ```json
    {
      "error": {
        "code": "E003",
        "message": "Invalid course ID provided."
      }
    }
    ```

---

## V. Testing Strategy

### 5.1 Test Cases
- **Assign a Teacher to a Course**: Validate that assigning a Teacher to a Course with a valid ID works as expected.
- **Retrieve Course Info Including Teacher**: Ensure that queries return Course details along with Teacher info.
- **Error for Nonexistent Course**: Confirm proper error messages when attempting to assign a Teacher to a nonexistent Course.
- **Conflict on Teacher Assignment**: Check that attempting to assign an already assigned Teacher returns an appropriate error.

### 5.2 Testing Framework
- Use `pytest` for organizing unit and integration tests, along with `httpx` for endpoint testing.

---

## VI. Implementation Steps

1. **Project Setup**
   - Ensure adherence to existing directory structure and module naming conventions.

2. **Database Migration**
   - Run the provided migration script to add the `teacher_id` column to the courses table.

3. **API Endpoint Development**
   - Implement `POST /courses/{course_id}/assign-teacher` and `GET /courses/{course_id}` in the existing API module for Courses.

4. **Input Validation & Error Handling**
   - Validate request data for assigning Teachers and ensure meaningful error responses based on the outlined specifications.

5. **Testing**
   - Develop tests covering all scenarios described prior, ensuring capability for both successful and erroneous operations.

6. **Documentation**
   - Update the API documentation generated by FastAPI to include new endpoints, outlining request bodies and error responses.

---

## VII. Version Control Practices

### 7.1 Git Hygiene
- Follow the established workflow for commits, making clear and detailed messages to indicate the purpose of each change.
- Organize alterations into logical sets, maintaining functionality with existing code.

---

## VIII. Conclusion

This implementation plan delineates the steps necessary for establishing a relationship between Courses and Teachers within the application, ensuring integration with existing structures while maintaining backward compatibility with current data practices. 

### Existing Code Files Modifications:
1. **models/course.py**: Add `teacher_id` to Course model.
    ```python
    class Course(Base):
        """Course model to store course information."""
        
        __tablename__ = 'courses'
        
        id = Column(Integer, primary_key=True)
        teacher_id = Column(Integer, ForeignKey('teachers.id'), nullable=True)  # Foreign key to Teacher
    ```

2. **api/courses.py**: Implement the new endpoints for assigning a Teacher and retrieving Course information.
    ```python
    from fastapi import APIRouter, HTTPException, Depends
    from models.course import Course
    from models.teacher import Teacher
    from sqlalchemy.orm import Session
    from db import get_db  # Assuming this provides the database session

    router = APIRouter()

    @router.post('/courses/{course_id}/assign-teacher')
    async def assign_teacher(course_id: int, teacher_id: int, db: Session = Depends(get_db)):
        # Validate and assign Teacher
        course = db.query(Course).filter(Course.id == course_id).first()
        if not course:
            raise HTTPException(status_code=404, detail="Course not found.")
        
        if course.teacher_id is not None:
            raise HTTPException(status_code=400, detail="A Teacher is already assigned to this Course.")

        course.teacher_id = teacher_id
        db.commit()
        return {"message": "Teacher successfully assigned to the Course."}

    @router.get('/courses/{course_id}')
    async def get_course(course_id: int, db: Session = Depends(get_db)):
        course = db.query(Course).filter(Course.id == course_id).first()
        if not course:
            raise HTTPException(status_code=404, detail="Course not found.")
        
        return {
            "id": course.id,
            "name": course.name,
            "teacher": {"id": course.teacher_id, ....}  # Assuming teacher details logic is defined
        }
    ```

3. **tests/test_courses.py**: Expand test suite to explore new functional coverage related to Teacher assignments for Courses.
    ```python
    @pytest.mark.asyncio
    async def test_assign_teacher_to_course():
        async with AsyncClient(app=app, base_url="http://test") as client:
            # Setup code to create a course, a teacher...
            response = await client.post("/courses/1/assign-teacher", json={"teacher_id": 1})
            assert response.status_code == 200
            assert response.json()["message"] == "Teacher successfully assigned to the Course."
    ```

Ultimately, this plan synthesizes the integration of a Teacher relationship with Courses, ensuring consistency within the evolving software architecture while preserving functional integrity and data continuity.