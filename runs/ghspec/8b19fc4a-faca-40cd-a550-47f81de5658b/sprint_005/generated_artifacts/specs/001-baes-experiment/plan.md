# Implementation Plan: Create Teacher Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Add Course Relationship to Student Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Create Course Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Add Email Field to Student Entity

## Version: 1.0.0  
**Purpose**: To outline the technical architecture, technology stack, implementation approach, and module design for adding a Teacher entity to the existing system.

---

## I. Project Architecture

### 1.1 Application Design
This implementation will enhance the existing microservices architecture by introducing a new Teacher entity. With FastAPI as the backend framework and SQLAlchemy to manage database operations, this implementation will align with the existing application structure.

### 1.2 Technology Stack
- **Backend Framework**: FastAPI (Python 3.11+)
- **Database**: SQLite
- **Data Access Layer**: SQLAlchemy for ORM
- **API Documentation**: Swagger (automatically generated by FastAPI)
- **Testing Framework**: pytest
- **Environment Variables**: python-dotenv for configuration management

---

## II. Module Design

### 2.1 Module Responsibilities
- **Teacher Management Module**
  - Introduce the Teacher entity that includes a name and a unique email.
  - Handle API logic for creating new Teacher records and retrieving Teacher details.

### 2.2 Component Breakdown
- **API Endpoints**
  - `POST /teachers`: Endpoint for creating a new Teacher.
  - `GET /teachers/{teacher_id}`: Endpoint for retrieving details of a specific Teacher.

---

## III. Database Migration Strategy

### 3.1 Schema Update
- Create a new Teacher table with the following columns:
  - **Table: teachers**
    - `id`: Integer, auto-incremented identifier for the Teacher (Primary Key).
    - `name`: String, required field to store the Teacher's name.
    - `email`: String, required field to store the Teacher's email, must be unique.

#### Migration Script
```python
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, UniqueConstraint
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "sqlite:///./database.db"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def upgrade():
    """Create Teacher table."""
    meta = MetaData(bind=engine)
    teachers = Table(
        'teachers',
        meta,
        Column('id', Integer, primary_key=True, autoincrement=True),
        Column('name', String, nullable=False),
        Column('email', String, nullable=False, unique=True),
        UniqueConstraint('email', name='uq_email')
    )
    meta.create_all(engine, checkfirst=True)  # Ensure the table gets created

def downgrade():
    """Drop the Teacher table if it exists."""
    with engine.connect() as conn:
        conn.execute("DROP TABLE IF EXISTS teachers;")

if __name__ == "__main__":
    upgrade()
```

---

## IV. API Design

### 4.1 API Endpoints

#### 4.1.1 Create a New Teacher
- **Request** (POST /teachers)
  - **Body**:
    ```json
    {
      "name": "John Doe",
      "email": "john.doe@example.com"
    }
    ```
- **Response** (201 Created)
  - **Body**:
    ```json
    {
      "id": 1,
      "message": "Teacher successfully created."
    }
    ```

#### 4.1.2 Retrieve Teacher Details
- **Request** (GET /teachers/{teacher_id})
- **Response** (200 OK)
  - **Body**:
    ```json
    {
      "id": 1,
      "name": "John Doe",
      "email": "john.doe@example.com"
    }
    ```

### 4.2 Error Handling

#### 4.2.1 Common Error Responses
- **Email Already Exists** (400 Bad Request)
  - **Response**:
    ```json
    {
      "error": {
        "code": "E001",
        "message": "Email already in use."
      }
    }
    ```
  
- **Invalid Request** (400 Bad Request)
  - **Response**:
    ```json
    {
      "error": {
        "code": "E002",
        "message": "Name and email fields are required."
      }
    }
    ```

---

## V. Testing Strategy

### 5.1 Test Cases
- **Create a Teacher**: Validate that creating a Teacher with valid attributes succeeds.
- **Validate Email Uniqueness**: Ensure trying to create a Teacher with an existing email returns an error.
- **Retrieve Teacher Details**: Confirm that the correct details are returned for an existing Teacher.
- **Error Handling for Invalid Data**: Ensure appropriate error messages when required fields are missing.

### 5.2 Testing Framework
- Use `pytest` to structure unit and integration tests.
- Use `httpx` for making requests to endpoints in tests.

---

## VI. Implementation Steps

1. **Project Setup**
   - Ensure the existing folder structure is maintained.
   - Update the virtual environment with any additional dependencies if necessary.

2. **Database Schema Update**
   - Apply the database migration to create the `teachers` table.
   - Ensure integrity and usability of existing Student and Course data.

3. **API Endpoint Development**
   - Implement the `POST /teachers` and `GET /teachers/{teacher_id}` endpoints in a new file called `api/teachers.py`.

4. **Input Validation & Error Handling**
   - Implement input validations for the Teacher creation requests.
   - Define structured error responses for missing fields and duplicate email scenarios.

5. **Testing**
   - Write unit tests for the new features, ensuring that all scenarios are covered.
   - Run integration tests to confirm the end-to-end functionality.

6. **Documentation**
   - Update the API documentation generated by FastAPI to include the new endpoints and their usage.

---

## VII. Version Control Practices

### 7.1 Git Hygiene
- Use detailed commit messages that clarify the rationale for changes.
- Follow best practices for organizing commits, ensuring they are atomic.

---

## VIII. Conclusion

This implementation plan details the approach for introducing the Teacher entity within the application. It includes the necessary database changes, new API endpoints, and a comprehensive testing strategy to ensure robustness and reliability of functionality while following existing coding standards and maintaining backward compatibility.

### Existing Code Files Modifications:
1. Create new file: `api/teachers.py` for new API endpoints related to Teacher management.
2. Update `api/errors.py` to handle new error cases related to Teacher entity creation.

### Existing Code Files:
- **models/teacher.py**: New file to define the Teacher model.
- **api/teachers.py**: Implement new endpoints for creating a Teacher and retrieving Teacher details.
- **tests/test_teachers.py**: New file for integration tests related to Teacher management functionality.

---

### Example of Existing Code Files:
**models/teacher.py**
```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Teacher(Base):
    """Teacher model to store teacher information."""
    
    __tablename__ = 'teachers'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    email = Column(String, nullable=False, unique=True)

    def __repr__(self):
        return f"<Teacher(id={self.id}, name={self.name}, email={self.email})>"
```

**api/teachers.py**
```python
from fastapi import APIRouter, HTTPException
from models.teacher import Teacher
from sqlalchemy.orm import Session
from db import get_db  # Assuming this provides the database session

router = APIRouter()

@router.post('/teachers')
async def create_teacher(teacher: TeacherCreate, db: Session = Depends(get_db)):
    # Validate and create a new Teacher
    existing_teacher = db.query(Teacher).filter(Teacher.email == teacher.email).first()
    if existing_teacher:
        raise HTTPException(status_code=400, detail="Email already in use.")
    
    new_teacher = Teacher(name=teacher.name, email=teacher.email)
    db.add(new_teacher)
    db.commit()
    db.refresh(new_teacher)
    return {"id": new_teacher.id, "message": "Teacher successfully created."}

@router.get('/teachers/{teacher_id}')
async def get_teacher(teacher_id: int, db: Session = Depends(get_db)):
    teacher = db.query(Teacher).filter(Teacher.id == teacher_id).first()
    if not teacher:
        raise HTTPException(status_code=404, detail="Teacher not found.")
    return {"id": teacher.id, "name": teacher.name, "email": teacher.email}
```

**tests/test_teachers.py**
```python
import pytest
from httpx import AsyncClient
from main import app  # Assuming your FastAPI app is defined in main.py

@pytest.mark.asyncio
async def test_create_teacher():
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post("/teachers", json={"name": "John Doe", "email": "john.doe@example.com"})
        assert response.status_code == 201
        assert "id" in response.json()

@pytest.mark.asyncio
async def test_create_teacher_with_existing_email():
    async with AsyncClient(app=app, base_url="http://test") as client:
        # First create a Teacher
        await client.post("/teachers", json={"name": "John Doe", "email": "john.doe@example.com"})
        # Attempt to create another Teacher with the same email
        response = await client.post("/teachers", json={"name": "Jane Doe", "email": "john.doe@example.com"})
        assert response.status_code == 400
        assert response.json() == {"error": {"code": "E001", "message": "Email already in use."}}
```

This plan establishes a clear approach for the addition of the Teacher entity, ensuring that all components align with the current application architecture.