# Implementation Plan: Create Course Entity with Name and Level Fields

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Add Email Field to Student Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Student Entity Management Web Application

## I. Project Overview

### 1.1 Purpose
The purpose of this implementation is to enhance the existing Student Entity Management Web Application by adding a new Course entity. This addition will facilitate the creation and management of courses, enabling a structured framework for educational offerings typically associated with students.

### 1.2 Goals
- Introduce a new Course model including mandatory fields for name and level.
- Ensure that both fields are validated and properly handled.
- Extend existing RESTful API to support CRUD operations for the new Course entity.
- Maintain backward compatibility with existing student records and functionality.

---

## II. Technical Architecture

### 2.1 Architecture Overview
- **Architecture Type**: Microservices-based
- **Service Layer**: Handles business logic and data management for courses in addition to students.
- **API Layer**: Exposes new RESTful endpoints for course management alongside existing student management.
- **Database**: SQLite, expanded with a new Course table while maintaining the structure of existing data.

### 2.2 Tech Stack
- **Programming Language**: Python 3.11+
- **Framework**: FastAPI for asynchronous request handling.
- **Database**: SQLite for lightweight data storage.
- **ORM**: SQLAlchemy for database interaction.
- **Testing**: Pytest for unit and integration tests.
- **Documentation**: OpenAPI spec generated by FastAPI.

---

## III. Module Boundaries and Responsibilities

### 3.1 API Layer
- **Endpoints**:
  - `POST /courses`: Create a new course with name and level.
  - `GET /courses`: Retrieve a list of all course records.
  - `PUT /courses/{id}`: Update an existing course's name or level based on ID.
  - `DELETE /courses/{id}`: Delete a course record.

### 3.2 Service Layer
- New service methods to accommodate course CRUD operations analogous to existing student services.
- Ensure validation for name and level fields throughout the service layer.

### 3.3 Database Layer
- Create a new Course entity that includes required fields along with primary key management.
- Implement the database migration scripts to add the Course table while keeping other existing tables intact.

---

## IV. Data Model

### 4.1 Course Entity
```python
from sqlalchemy import Column, Integer, String
from database import Base

class Course(Base):
    __tablename__ = 'courses'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    level = Column(String, nullable=False)  # Both fields are required

    def __repr__(self):
        return f"<Course(id={self.id}, name='{self.name}', level='{self.level}')>"
```

### 4.2 SQLite Schema Migration
- Create a migration script to define the new Course table:
```sql
CREATE TABLE courses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    level TEXT NOT NULL
);
```

- Ensure that existing student records remain unaffected, and populate any potential defaults as needed.

---

## V. API Contracts

### 5.1 Request/Response Formats

1. **Create Course**
   - **Request**: 
     - Method: POST
     - Body: `{"name": "Math 101", "level": "Beginner"}`
   - **Response**: 
     - Status: 201 Created
     - Body: `{"id": 1, "name": "Math 101", "level": "Beginner"}`

2. **Get All Courses**
   - **Request**: 
     - Method: GET
   - **Response**: 
     - Status: 200 OK
     - Body: `[{"id": 1, "name": "Math 101", "level": "Beginner"}, ...]`

3. **Update Course**
   - **Request**: 
     - Method: PUT
     - URL: `/courses/1`
     - Body: `{"name": "Math 102", "level": "Intermediate"}`
   - **Response**: 
     - Status: 200 OK
     - Body: `{"id": 1, "name": "Math 102", "level": "Intermediate"}`

4. **Delete Course**
   - **Request**: 
     - Method: DELETE
     - URL: `/courses/1`
   - **Response**: 
     - Status: 204 No Content

### 5.2 Error Handling
- Possible responses with status codes:
  - 400 Bad Request: for validation errors (missing name or level).
  - 404 Not Found: when a course record doesn’t exist.

---

## VI. Implementation Strategy

### 6.1 Development Phases
1. **Setup Development Environment**
   - Verify that environment supports Python 3.11+, FastAPI, SQLAlchemy, and Pytest.

2. **Develop API Layer**
   - Implement the required endpoints for courses.
   - Validate incoming requests for course creation:
   ```python
   from pydantic import BaseModel

   class CourseCreate(BaseModel):
       name: str
       level: str  # Both fields are required

   class CourseUpdate(BaseModel):
       name: Optional[str]
       level: Optional[str]
   ```

3. **Develop Service Layer**
   - Create new service methods for course management:
     ```python
     def create_course(course: CourseCreate) -> Course:
         validated_course = validate_course(course)
         return Course(name=validated_course.name, level=validated_course.level)
     ```

4. **Database Initialization**
   - Write migration scripts for Course table creation and run it during app startup.

5. **Testing**
   - Write unit tests for CRUD operations on Course objects.
   - Validate responses for each operation, including error cases.

6. **Documentation**
   - Update OpenAPI documentation to include new course endpoints.

### 6.2 Code Review & Validation
- Follow the coding standards outlined in the Default Project Constitution.
- Require thorough code reviews especially focused on functionality and adherence to APIs.

---

## VII. Testing Strategy

### 7.1 Unit Tests
- Each function in the service layer related to Course will have corresponding unit tests to ensure correctness.

### 7.2 Integration Tests
- Test API integration with the database to confirm that CRUD operations work seamlessly for the Course entity.

### 7.3 Test Coverage
- Aim for a minimum of 70% coverage for business logic related to courses, focusing on critical paths for over 90% coverage.

### 7.4 Test Scenarios
1. Create course with valid name and level; validate successful creation.
2. Attempt to create course with missing fields and validate error response.
3. Retrieve courses and check if all fields are present in JSON response.
4. Update a course’s name and level and verify persistence in the database.
5. Delete a course and ensure the record is removed.

---

## VIII. Security Considerations

- Validate input to ensure correct data entry and prevent vulnerabilities.
- Sanitize all inputs to mitigate potential SQL injection risks.

---

## IX. Deployment Considerations

- Document all environment-specific configuration and migration steps.
- Ensure that migrations are reversible and that they can be run without impacting existing student data.

---

## X. Conclusion

This implementation plan outlines the necessary steps to create a Course entity within the Student Entity Management Web Application. By focusing on proper validation, ensuring backward compatibility, and thorough testing, this implementation will enhance user experience while adhering to existing architectural standards. 

### Modifications Needed to Existing Files
- **Model Changes**: Introduce a new Course model definition.
- **Migration Handling**: Create migration files to define the Course table.
- **API Endpoints**: Update FastAPI routes to include course management.
- **Testing Files**: Create or extend `tests/api/test_course_api.py` and `tests/service/test_course_service.py` to include tests for course management.

Existing Code Files:
File: tests/api/test_student_api.py
```python
import pytest
from fastapi.testclient import TestClient
from src.main import app
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from src.models import Student, Course  # Import Course model for integration testing

# Configure the SQLite database for testing
SQLALCHEMY_DATABASE_URL = "sqlite:///./test_db.sqlite3"
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

@pytest.fixture(scope="module")
def test_client():
    app.dependency_overrides[get_db] = lambda: TestingSessionLocal()  # Use the test DB
    yield TestClient(app)
```

File: tests/service/test_student_service.py
```python
import pytest
from sqlalchemy.orm import Session
from src.models import Student, Course  # Import the Course model
from src.services.student_service import create_student, get_student, update_student, delete_student
from src.services.course_service import create_course, get_courses  # New imports for courses
from src.database import get_db

@pytest.fixture
def test_db():
    # Set up a test database connection and session
    db = get_db()
    yield db
    db.rollback()
    db.close()

def test_create_course(test_db: Session):
    # Test data for creating a course
    new_course = {"name": "Art 101", "level": "Beginner"}
    course = create_course(test_db, new_course)
    assert course.name == new_course["name"]
    assert course.level == new_course["level"]
```

This structured approach ensures efficient integration of the Course entity into the existing framework while maintaining the application's integrity and adherence to development standards.