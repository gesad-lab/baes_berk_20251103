# Implementation Plan: Add Teacher Relationship to Course Entity

---
## INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Create Teacher Entity

## Version
1.0.0

## Purpose
To implement a feature establishing a relationship between the Course and Teacher entities within the existing educational application. This feature enhances course management via teacher assignments, facilitating tracking and reporting functionalities which are crucial as the application scales.

## Technology Stack
- **Backend Framework**: FastAPI (Python)
- **Database**: PostgreSQL
- **ORM**: SQLAlchemy
- **Data Validation**: Pydantic
- **API Documentation**: Swagger (automatically provided by FastAPI)
- **Testing Framework**: pytest
- **Deployment**: Docker for containerization
- **Environment Management**: .env files for configuration 

## Architectural Overview
The application architecture maintains a separation of concerns by interacting through defined layers:
- **API Layer**: Handles HTTP requests for teacher-course assignments and course queries including teacher details.
- **Service Layer**: Contains business logic for assigning teachers to courses and retrieving course information.
- **Data Access Layer**: Manages database operations using SQLAlchemy.
- **Database Layer**: Updates the schema to incorporate the new teacher-course relationship.

## Module Responsibilities

### 1. API Layer
- Manages incoming requests for teacher assignments to courses and course detail retrieval, mapping to corresponding service methods, including input validation.

### 2. Service Layer
- Will implement the assignment logic to relate a teacher to a course and fetch details, ensuring that operations fail gracefully in case of invalid requests.

### 3. Data Access Layer
- Performs CRUD operations for the new relationship between Courses and Teachers in the database through SQLAlchemy.

## Data Models

### Course Model (Updated)
In the existing `src/models/course.py`, we will update the model to include the relationship with the Teacher entity:

```python
from sqlalchemy import Column, Integer, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Course(Base):
    __tablename__ = 'courses'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    # ... other fields ...
    teacher_id = Column(Integer, ForeignKey('teachers.id'), nullable=True)

    teacher = relationship("Teacher", back_populates="courses")
```

### Teacher Model (Existing)
No changes necessary; includes fields already defined in the previous implementation.

### Teacher Relationship Attribute
Update the `Teacher` model in `src/models/teacher.py` to define the reverse relationship:

```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class Teacher(Base):
    __tablename__ = 'teachers'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(255), nullable=False)
    email = Column(String(255), nullable=False, unique=True)

    courses = relationship("Course", back_populates="teacher")
```

## API Contracts

### Assign Teacher to Course
- **Endpoint**: `POST /courses/{courseId}/assign-teacher`
- **Request Body**:
    ```json
    {
        "teacherId": 1
    }
    ```
- **Response** (Success - 200 OK):
    ```json
    {
        "message": "Teacher assigned successfully.",
        "courseId": 1,
        "teacherId": 1
    }
    ```

### Retrieve Course with Teacher Information
- **Endpoint**: `GET /courses/{courseId}`
- **Response** (Success - 200 OK):
    ```json
    {
        "id": 1,
        "title": "Mathematics",
        "teacher": {
            "name": "John Doe",
            "email": "john.doe@example.com"
        } 
    }
    ```

## Implementation Steps

1. **Project Setup**
   - Ensure the project structure adheres to previous implementations.
   - Verify PostgreSQL settings in the Docker configuration for migration and operations remain consistent.

2. **Database Migration**
   - Create a migration for adding the `teacher_id` column to the `Courses` table using Alembic:
   ```bash
   alembic revision --autogenerate -m "Add teacher_id to Courses"
   ```

   Update the migration script generated by Alembic:
   ```python
   def upgrade():
       op.add_column('courses', sa.Column('teacher_id', sa.Integer(), nullable=True))
       op.create_foreign_key('fk_teacher_course', 'courses', 'teachers', ['teacher_id'], ['id'])

   def downgrade():
       op.drop_constraint('fk_teacher_course', 'courses', type_='foreignkey')
       op.drop_column('courses', 'teacher_id')
   ```

3. **API Development**
   - Extend the current API module in `src/routes/courses.py`:
   ```python
   from fastapi import APIRouter, HTTPException, Depends
   from sqlalchemy.orm import Session
   from ..models.course import Course
   from ..models.teacher import Teacher
   from ..database import get_db
   from pydantic import BaseModel

   router = APIRouter()

   class TeacherAssignment(BaseModel):
       teacherId: int

   @router.post("/courses/{course_id}/assign-teacher", status_code=200)
   async def assign_teacher(course_id: int, assignment: TeacherAssignment, db: Session = Depends(get_db)):
       course = db.query(Course).filter(Course.id == course_id).first()
       if not course:
           raise HTTPException(status_code=404, detail="Course not found.")
       
       teacher = db.query(Teacher).filter(Teacher.id == assignment.teacherId).first()
       if not teacher:
           raise HTTPException(status_code=404, detail="Teacher not found.")
       
       course.teacher_id = assignment.teacherId
       db.commit()
       return {"message": "Teacher assigned successfully.", "courseId": course_id, "teacherId": assignment.teacherId}

   @router.get("/courses/{course_id}")
   async def get_course_by_id(course_id: int, db: Session = Depends(get_db)):
       course = db.query(Course).filter(Course.id == course_id).first()
       if not course:
           raise HTTPException(status_code=404, detail="Course not found.")
       return {
           "id": course.id,
           "title": course.title,
           "teacher": {"name": course.teacher.name, "email": course.teacher.email} if course.teacher else None
       }
   ```

4. **Update Main Application**
   - Include the new routes in the main FastAPI application module in `src/main.py`:
   ```python
   from fastapi import FastAPI
   from .routes.courses import router as course_router

   app = FastAPI()

   app.include_router(course_router)
   ```

5. **Testing**
   - Create a test file `tests/test_courses.py`:
   ```python
   from fastapi.testclient import TestClient
   from main import app

   client = TestClient(app)

   def test_assign_teacher_to_course():
       response = client.post("/courses/1/assign-teacher", json={"teacherId": 1})
       assert response.status_code == 200
       assert response.json() == {
           "message": "Teacher assigned successfully.",
           "courseId": 1,
           "teacherId": 1
       }

   def test_get_course_with_teacher():
       response = client.get("/courses/1")
       assert response.status_code == 200
       assert response.json()["teacher"] is not None

   def test_assign_teacher_non_existing_course():
       response = client.post("/courses/999/assign-teacher", json={"teacherId": 1})
       assert response.status_code == 404
       assert response.json() == {'detail': 'Course not found.'}
   ```

6. **Documentation**
   - Verify the Swagger documentation updates correctly to reflect the new API endpoints (`/courses/{courseId}/assign-teacher`, `/courses/{courseId}`).

7. **Deployment**
   - Validate the migration against the local PostgreSQL database.
   - Update the Docker setup as necessary to ensure compatibility with the migrations and new functionalities.

## Success Criteria
- **Teacher Assignment Success**: Assigning a teacher returns a 200 response and confirmation of the assignment.
- **Course Retrieval Success**: Returns a 200 response with course details including the assigned teacher if available.
- **Invalid Course Handling**: Attempting assignment to a non-existent course yields a clear 404 error message.
- **Successful Migration**: The application works seamlessly post-migration, maintaining integrity with previous data and functionality.

## Trade-offs and Considerations
- **Migration Complexity**: Adding a column while ensuring backwards compatibility entails additional testing and validation to ensure smooth operation.
- **Error Handling**: Feedback for invalid requests should be comprehensive yet straightforward for user understanding; improvements can be made in future releases.
- **Testing Coverage**: Tests are essential to safeguarding existing functionalities after integration. Increase coverage in future iterations to include edge cases.

## Conclusion
By successfully establishing a relationship between the Course and Teacher entities, these implementations strengthen the foundation for improved course management, and adhere closely to architectural integrity and maintainability principles established throughout previous features. This will enable better data management and administrative capabilities as the application evolves.

Existing Code Files:
File: tests/test_courses.py
```python
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_assign_teacher_to_course():
    response = client.post("/courses/1/assign-teacher", json={"teacherId": 1})
    assert response.status_code == 200

def test_get_course_with_teacher():
    response = client.get("/courses/1")
    assert response.status_code == 200
        
def test_assign_teacher_non_existing_course():
    response = client.post("/courses/999/assign-teacher", json={"teacherId": 1})
    assert response.status_code == 404
```