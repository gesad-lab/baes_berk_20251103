# Tasks: Add Email Field to Student Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Existing Code to Build Upon:
- tests/test_students.py (3131 bytes)

---

## Task Breakdown

### 1. Modify Student Model
- **Task**: Add `email` field to the existing `Student` model.
- **File**: `src/models/student.py`
- **Action**:
    ```python
    # src/models/student.py
    class Student(Base):
        __tablename__ = 'students'
        
        id = Column(Integer, primary_key=True, autoincrement=True)
        name = Column(String(255), nullable=False)
        email = Column(String(255), nullable=False)  # New email field
    ```
- [ ] Add `email` field to the Student model.

### 2. Implement Database Migration
- **Task**: Create a migration script to add the `email` field to the existing `students` table.
- **File**: `src/migrations/versions/002_add_email_to_student.py`
- **Action**:
    ```python
    # src/migrations/versions/002_add_email_to_student.py
    from alembic import op
    import sqlalchemy as sa

    def upgrade():
        op.add_column('students', sa.Column('email', sa.String(length=255), nullable=False))

    def downgrade():
        op.drop_column('students', 'email')
    ```
- [ ] Create migration script to include `email` in the Student table.

### 3. Update Create Student API Endpoint
- **Task**: Modify `POST /students` endpoint to accept `email` in the request body.
- **File**: `src/api/routes/students.py`
- **Action**:
    ```python
    # src/api/routes/students.py
    from pydantic import BaseModel, EmailStr

    class StudentCreate(BaseModel):
        name: str
        email: EmailStr  # Use EmailStr for email validation

    @app.post("/students")
    async def create_student(student: StudentCreate):
        # Logic to create student including email...
    ```
- [ ] Update `POST /students` logic to process `email`.

### 4. Add Error Handling for Missing Email
- **Task**: Implement error handling for requests without an email field.
- **File**: `src/api/routes/students.py`
- **Action**:
    ```python
    # src/api/routes/students.py
    if not student.email:
        raise HTTPException(status_code=400, detail="Email field is required.")
    ```
- [ ] Add error handling for missing email in the request.

### 5. Implement Retrieve All Students API Endpoint
- **Task**: Ensure `GET /students` returns the student records with email.
- **File**: `src/api/routes/students.py`
- **Action**:
    ```python
    # src/api/routes/students.py
    @app.get("/students")
    async def get_students():
        # Logic to retrieve all students including email...
    ```
- [ ] Ensure all students are returned with their email addresses.

### 6. Extend Unit Tests for Email Functionality
- **Task**: Add tests for creating a student and missing email scenarios in the test suite.
- **File**: `tests/test_students.py`
- **Action**:
    ```python
    # tests/test_students.py
    def test_create_student_with_email():
        # Simulate the creation of a student with email...

    def test_create_student_missing_email():
        # Simulate the error response for missing email...
    ```
- [ ] Extend test suite for new email functionalities.

### 7. Verify API Documentation
- **Task**: Check that the API documentation reflects the changes made.
- **File**: Automatically generated by FastAPI, no specific file.
- **Action**: 
    ```markdown
    # Check Swagger UI
    - [ ] Validate documentation shows new email field in requests for POST /students.
    ```
- [ ] Ensure API documentation is updated to show email field requirements.

### 8. Review and Update Deployment Configuration
- **Task**: Confirm Docker setup and update `.env.example` if necessary.
- **File**: `.env.example`
- **Action**:
    ```plaintext
    # .env.example (if new configurations are needed)
    # e.g., DATABASE_URL=postgresql://user:password@localhost/dbname
    ```
- [ ] Review/update `.env.example` based on any configuration changes.

---

This task breakdown outlines specific, actionable steps to successfully implement the addition of an email field to the Student entity while adhering to the outlined specifications and maintaining best practices in coding and testing. Each task is file-scoped and can be executed independently, ensuring testability and incremental integration into the application.