# Tasks: Create Course Entity

---

## INCREMENTAL DEVELOPMENT CONTEXT

### Existing Code to Build Upon:
- `models/course.py` (new file)
- `schemas/course_schema.py` (new file)
- `routes/course_routes.py` (new file)
- Existing files for the Student entity as references

---

## Task Breakdown

### Task 1: Create Course Model

- **File**: `src/models/course.py`
- **Task**: Define a new SQLAlchemy model called `Course` with `id`, `name`, and `level` fields.
- **Description**: Create a new file and implement the model structure for the Course entity, ensuring it adheres to the specified schema.

```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Course(Base):
    __tablename__ = 'courses'

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    level = Column(String, nullable=False)
```
- [ ] Task complete

---

### Task 2: Define Course Request/Response Schemas

- **File**: `src/schemas/course_schema.py`
- **Task**: Implement Pydantic models for request and response validation for the Course API.
- **Description**: Create a new file to define the `CourseSchema` for validating incoming requests and structuring outgoing responses.

```python
from pydantic import BaseModel

class CourseSchema(BaseModel):
    id: int
    name: str
    level: str

    class Config:
        orm_mode = True
```
- [ ] Task complete

---

### Task 3: Develop Course API Routes

- **File**: `src/routes/course_routes.py`
- **Task**: Implement the API routes for creating and retrieving courses.
- **Description**: Create a new file to define API endpoints: `POST /courses` and `GET /courses/{id}`, handling the requests accordingly.

```python
from fastapi import APIRouter, HTTPException
from models.course import Course
from schemas.course_schema import CourseSchema
from database import SessionLocal

router = APIRouter()

@router.post("/courses", response_model=CourseSchema)
def create_course(course: CourseSchema):
    # Integration logic to create course and return its details
    pass

@router.get("/courses/{id}", response_model=CourseSchema)
def get_course(id: int):
    # Integration logic to get course by ID
    pass
```
- [ ] Task complete

---

### Task 4: Set Up Database Migration for Courses Table

- **File**: Migration Script (generated by Alembic)
- **Task**: Create a migration script that adds the `courses` table to the database schema.
- **Description**: Use Alembic to create a new migration script and define the table schema, ensuring it can be applied without affecting existing Student data.

```bash
alembic revision --autogenerate -m "Create courses table"
```
- [ ] Task complete

---

### Task 5: Implement Error Handling for Course Creation

- **File**: `src/routes/course_routes.py`
- **Task**: Add validation logic to handle errors for missing name or level fields during course creation.
- **Description**: Enhance the create_course function to check for required fields and return structured error messages as per API contracts.

```python
# Add validation logic here
```
- [ ] Task complete

---

### Task 6: Write Unit and Integration Tests for Course API

- **File**: `tests/test_course_routes.py`
- **Task**: Develop tests for creating and retrieving courses, covering both success and failure cases.
- **Description**: Mirror the structure of the source code, writing unit tests for individual functions and integration tests for API endpoints.

```python
# Example test function to verify course creation
def test_create_course():
    # Test logic and assertions
    pass
```
- [ ] Task complete

---

### Task 7: Update Documentation in README.md

- **File**: `README.md`
- **Task**: Document the new API functionality for the Course entity.
- **Description**: Ensure that the README reflects the new routes, expected request/response formats, and how to interact with the Course API.

- [ ] Task complete

---

By executing these tasks, the implementation of the Course entity will be well-structured, ensuring that functionality is independently testable and integrates seamlessly with existing code structure.