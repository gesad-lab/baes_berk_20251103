# Implementation Plan: Add Course Relationship to Student Entity

---

## INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Create Course Entity

---

## Version
**Version**: 1.1.0  
**Date**: 2023-10-10

---

## 1. Project Overview
The purpose of this feature is to establish a relationship between the existing Student entity and the new Course entity. By enabling each student to be associated with multiple courses, this implementation enhances academic tracking and management capabilities. The relationship is crucial for allowing students to enroll in courses, enriching their educational journey.

---

## 2. Technical Architecture

### 2.1 Overall Architecture
- **Architecture Pattern**: Microservices architecture continues to support `Student` and `Course` integration.
- **Tech Stack**: 
  - **Web Framework**: FastAPI (lightweight and asynchronous capabilities)
  - **Database**: SQLite (for local use and simplicity)
  - **ORM**: SQLAlchemy (for database interactions)
  - **Testing**: pytest (for robust testing)
  - **Dependency Management**: Poetry (for simplified package management)
  - **API Documentation**: OpenAPI (auto-generated by FastAPI)

### 2.2 Module Boundaries
- **Student Service Module**:
  - Responsible for all CRUD operations related to the Student entity remains untouched.
  
- **Course Service Module** (New):
  - Responsible for CRUD operations related to the Course entity and its relationship with Students.
  
- **Association Functionality**:
  - Introduced within the Student Service to handle associations between Students and Courses through a new `student_courses` table.

---

## 3. Implementation Approach

### 3.1 Directory Structure
```plaintext
student_entity_app/
│
├── src/
│   ├── __init__.py
│   ├── main.py                     # Entry point for the application
│   ├── models.py                   # Database models (SQLAlchemy)
│   ├── schemas.py                  # Data validation schemas (Pydantic)
│   ├── routes/
│   │   ├── __init__.py
│   │   ├── student_routes.py        # API routes for student endpoints
│   │   ├── course_routes.py         # API routes for course endpoints
│   └── database.py                  # Database connection and initialization
│
├── tests/
│   ├── __init__.py
│   ├── test_student.py              # Test cases for student routes
│   ├── test_course.py               # Test cases for course routes (new)
│   └── test_associations.py         # Test cases for student-course associations
│
├── config/
│   └── .env                         # Environment variables
│
├── requirements.txt                 # Dependencies file
└── README.md                        # Project documentation
```

### 3.2 Database Models
#### Modified Student and Course Models
Add a new `student_courses` association table to handle the many-to-many relationship.
```python
# models.py
from sqlalchemy import Column, Integer, ForeignKey, Table
from sqlalchemy.orm import relationship
from database import Base

# Association table
student_courses = Table('student_courses', Base.metadata,
    Column('student_id', Integer, ForeignKey('students.id')),
    Column('course_id', Integer, ForeignKey('courses.id'))
)

class Student(Base):
    __tablename__ = 'students'

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    email = Column(String, nullable=False)
    courses = relationship('Course', secondary=student_courses, back_populates='students')

class Course(Base):
    __tablename__ = 'courses'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    level = Column(String, nullable=False)
    students = relationship('Student', secondary=student_courses, back_populates='courses')
```

### 3.3 API Endpoints
- **POST /student/{student_id}/courses**
  - **Request**: JSON body with course IDs to associate with the student.
  - **Response**: JSON success message or error for non-existent course IDs.

- **GET /student/{student_id}**
  - **Response**: JSON with student details along with a list of associated courses.

### 3.4 Application Startup
- Modify the existing application to include migration setup for the new `student_courses` table, ensuring it gets created with the application startup.

### 3.5 Error Handling
- Implement check to ensure course IDs provided for association exist. Return structured JSON error messages when they do not.

---

## 4. Testing Approach

### 4.1 Test Coverage
- Establish a minimum of 70% coverage across all modules, focusing on critical paths for associating and retrieving courses for students.

### 4.2 Test Types
- **Unit Tests**: Validate individual functions and methods for course associations.
- **Integration Tests**: Check interactions with the SQLite database, particularly for adding courses to a student.
- **Contract Tests**: Verify API responses for both success and error cases.

### 4.3 Testing Structure
- New tests for CRUD functionalities for course associations are included in `test_associations.py`.

```python
# tests/test_associations.py
import pytest

def test_associate_student_with_courses(client):
    response = client.post("/student/1/courses", json={"course_ids": [1, 2]})
    assert response.status_code == 200
    assert response.json() == {"message": "Courses associated successfully"}

def test_associate_non_existent_course(client):
    response = client.post("/student/1/courses", json={"course_ids": [999]})
    assert response.status_code == 404
    assert response.json() == {"error": {"code": "E002", "message": "Course ID 999 does not exist."}}
```

---

## 5. Error Handling & Validation
- Validate incoming requests to ensure valid student IDs and course IDs are provided.
- Implement suitable JSON error responses for invalid requests.

```json
{
  "error": {
    "code": "E002",
    "message": "Course ID 999 does not exist."
  }
}
```

---

## 6. API Design Considerations
- Use route naming conventions consistent with RESTful design principles, ensuring clear, defined endpoints for course associations.
- Maintain proper HTTP status codes reflecting the operation's outcome.

---

## 7. Database Migration Strategy
Utilize Alembic to manage schema changes, ensuring the creation of the `student_courses` table without data loss during migration.
### Migration Script Example
```python
# migrations/versions/xxxx_create_student_courses_table.py
from alembic import op
import sqlalchemy as sa

def upgrade():
    op.create_table(
        'student_courses',
        sa.Column('student_id', sa.Integer(), sa.ForeignKey('students.id'), primary_key=True),
        sa.Column('course_id', sa.Integer(), sa.ForeignKey('courses.id'), primary_key=True)
    )

def downgrade():
    op.drop_table('student_courses')
```

---

## 8. Logging & Monitoring
Implement structured logging to capture significant events throughout the student-course association process, aiding in monitoring and troubleshooting.

---

## 9. Documentation
Update the `README.md` to reflect the new changes including the associations, API endpoints for CRUD operations related to courses, and examples of how to interact with these endpoints.

---

## 10. Success Criteria Check
1. **Successful Association**: Validate that students can be associated with multiple courses successfully.
2. **Retrieve Associations**: Ensure retrieving a student's details includes their associated courses.
3. **Error Handling Validation**: Confirm the appropriate error messages for non-existent course associations are returned.
4. **Data Integrity Post-Migration**: Verify that all existing student and course data remains intact after the migration.
5. **Backward Compatibility**: Existing functionalities are not disrupted, and data models remain operable.

---

This implementation plan outlines the steps for integrating the new course association functionality while preserving existing architecture principles and ensuring backward compatibility. The addition of the `student_courses` table facilitates collaboration between students and courses, enabling better tracking and management of educational enrollments.