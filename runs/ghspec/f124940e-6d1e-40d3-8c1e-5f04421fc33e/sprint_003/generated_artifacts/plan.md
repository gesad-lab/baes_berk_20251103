# Implementation Plan: Create Course Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Add Email Field to Student Entity

## Version
1.0.0

## Purpose
To enhance the existing educational web application by adding functionality to manage Course entities, enabling the creation, retrieval, and updating of course records.

## Architecture Overview
- **Architecture Style**: RESTful API
- **Framework**: FastAPI for building the RESTful API
- **Database**: SQLite or PostgreSQL for persistent storage
- **ORM**: SQLAlchemy for database interaction
- **Testing Framework**: pytest for testing
- **Containerization**: Docker for deployment (optional)

## Technology Stack
- **Backend**: 
  - FastAPI for handling HTTP requests and responses
  - SQLAlchemy for ORM
  - Pydantic for data validation
- **Database**:
  - SQLite for development and testing; PostgreSQL for production
- **Testing**: pytest for unit and integration tests
- **Environment Management**: Poetry or pip for dependencies management
- **Documentation**: OpenAPI automatically generated by FastAPI

## System Design

### Module Boundaries
1. **API Layer**:
   - Responsible for handling incoming requests for courses, routing to appropriate service, and returning responses.

2. **Service Layer**:
   - Contains application logic for creating, retrieving, and updating course records.

3. **Data Access Layer**:
   - Interacts with the database to manage course records.

4. **Models**:
   - Defines the Course entity and database schema.

### Data Model
```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Course(Base):
    __tablename__ = 'courses'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    level = Column(String, nullable=False)
```

### API Contracts
#### 1. Create Course
- **Endpoint**: `POST /courses`
- **Request Body**: 
  ```json
  {
    "name": "Mathematics",
    "level": "Intermediate"
  }
  ```
- **Response**:
  - **201 Created**:
  ```json
  {
    "id": 1,
    "name": "Mathematics",
    "level": "Intermediate"
  }
  ```

#### 2. Retrieve All Courses
- **Endpoint**: `GET /courses`
- **Response**:
  - **200 OK**:
  ```json
  [
    { "id": 1, "name": "Mathematics", "level": "Intermediate" },
    { "id": 2, "name": "Science", "level": "Beginner" }
  ]
  ```

#### 3. Update Course
- **Endpoint**: `PUT /courses/{id}`
- **Request Body**: 
  ```json
  {
    "name": "Mathematics",
    "level": "Advanced"
  }
  ```
- **Response**:
  - **200 OK**:
  ```json
  {
    "id": 1,
    "name": "Mathematics",
    "level": "Advanced"
  }
  ```

#### 4. Error Validation for Course Creation
- **Validation**: Both name and level fields must be provided during creation.
- **Response**: 400 Bad Request with error message if required fields are missing.

## Implementation Steps

### Step 1: Project Setup
- Ensure the project structure is as follows:
  ```
  .
  ├── src/
  │   ├── main.py         # FastAPI app
  │   ├── models.py       # Update existing models or create new models for Course
  │   ├── services/       # CRUD logic for Course
  │   ├── database.py     # DB connection and setup
  │   └── routers/        # API routes for Course
  ├── tests/              # Unit and integration tests
  ├── requirements.txt    # Dependency file (if required)
  └── .env.example         # Example environment configuration
  ```

### Step 2: Database Migration
- Implement a migration script to create the `courses` table:
  - Use Alembic for managing database migrations:
    - Generate migration file: `alembic revision --autogenerate -m "Create courses table"`
    - Ensure the migration script includes the create statement for the `courses` table:
      ```python
      def upgrade():
          op.create_table(
              'courses',
              sa.Column('id', sa.Integer, primary_key=True, autoincrement=True),
              sa.Column('name', sa.String, nullable=False),
              sa.Column('level', sa.String, nullable=False),
          )
      ```
    - Make sure the migration does not affect existing Student data.

### Step 3: Update Models
- Create a new `Course` model in `models.py` if not yet created:
  
```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Course(Base):
    __tablename__ = 'courses'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    level = Column(String, nullable=False)
```

### Step 4: API Implementation
- Create API handlers in FastAPI for CRUD operations on courses.
- Define a new router module in `routers/courses.py`:
  
```python
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from .models import Course
from .database import session  # Assuming there's a session object to interact with DB

router = APIRouter()

class CourseCreate(BaseModel):
    name: str
    level: str

class CourseResponse(BaseModel):
    id: int
    name: str
    level: str

@router.post("/courses", response_model=CourseResponse)
def create_course(course: CourseCreate):
    new_course = Course(name=course.name, level=course.level)
    session.add(new_course)
    session.commit()
    session.refresh(new_course)
    return new_course

@router.get("/courses", response_model=list[CourseResponse])
def get_courses():
    return session.query(Course).all()

@router.put("/courses/{course_id}", response_model=CourseResponse)
def update_course(course_id: int, course: CourseCreate):
    existing_course = session.query(Course).filter(Course.id == course_id).first()
    if not existing_course:
        raise HTTPException(status_code=404, detail="Course not found")
    existing_course.name = course.name
    existing_course.level = course.level
    session.commit()
    session.refresh(existing_course)
    return existing_course
```

### Step 5: Input Validation
- Use Pydantic in `CourseCreate` class to validate the inputs for course creation.

### Step 6: Testing
- Write unit tests to cover each user scenario for Course management:
  - Test creating a course.
  - Test retrieving all courses.
  - Test updating a course.
  - Test validation error when required fields are missing.

```python
import pytest
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

def test_create_course():
    response = client.post("/courses", json={"name": "Math 101", "level": "Beginner"})
    assert response.status_code == 201
    assert response.json()["name"] == "Math 101"

def test_create_course_missing_fields():
    response = client.post("/courses", json={"name": ""})
    assert response.status_code == 400
    assert "name" in response.json()["detail"][0]["loc"]
```

### Step 7: Documentation
- Ensure proper OpenAPI documentation is generated by FastAPI to document new endpoints and request/response formats.

### Step 8: Deployment Setup
- Update Docker configurations if using Docker to ensure compatibility with changes.

## Security Considerations
- Implement input sanitization to prevent injection attacks when saving course data.
- Validate input data on the API layer with clear error messages for missing or invalid inputs.

## Success Criteria
- Ensure that all CRUD operations on courses function as specified, returning appropriate JSON responses.
- Maintain a minimum test coverage of 70% for the new course management logic.
- Successfully create database migrations that do not disrupt existing student data.

## Technical Trade-offs
- **Choosing SQLite vs PostgreSQL**: For simpler development and testing, SQLite could be used, but for production environments where multi-user access and performance are crucial, PostgreSQL is recommended.

## Scalability & Maintainability
- Follow principles defined in the project constitution to ensure code consistency, making future feature additions easier and the codebase more maintainable.

## Conclusion
This implementation plan provides a clear, structured approach to implementing the Course entity in the system, ensuring that development efforts align with the specification requirements.

---

Existing Code Files:
1. **models.py**:
   - Add the Course model as described above.
   
2. **routers**:
   - Create a new `routers/courses.py` file for API endpoints related to Course.

3. **tests**:
   - New tests for the Course entity implementation will be placed in `tests/test_courses.py`:

```python
import pytest
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

def test_create_course():
    response = client.post("/courses", json={"name": "Math 101", "level": "Beginner"})
    assert response.status_code == 201
    assert response.json()["name"] == "Math 101"

def test_create_course_missing_fields():
    response = client.post("/courses", json={"name": ""})
    assert response.status_code == 400
    assert "level" in response.json()["detail"][0]["loc"]
``` 

This implementation plan outlines how new Course functionality integrates within the existing architecture of the application while adhering to established guidelines and ensuring backward compatibility.