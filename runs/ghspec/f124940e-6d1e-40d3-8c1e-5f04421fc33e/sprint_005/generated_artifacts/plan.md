# Implementation Plan: Create Teacher Entity

---
## INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Add Course Relationship to Student Entity

---
## Version
1.0.0

## Purpose
To enhance the existing educational web application by introducing a new "Teacher" entity, allowing the application to manage teacher data effectively and improving administrative efficiency.

## Architecture Overview
- **Architecture Style**: RESTful API
- **Framework**: FastAPI for building the RESTful API
- **Database**: SQLite for development and PostgreSQL for production
- **ORM**: SQLAlchemy for database interaction
- **Testing Framework**: pytest for testing
- **Containerization**: Docker for deployment (optional)

## Technology Stack
- **Backend**: 
  - **FastAPI** for handling HTTP requests and responses
  - **SQLAlchemy** for ORM
  - **Pydantic** for data validation
- **Database**:
  - **SQLite** for development and testing; **PostgreSQL** for production
- **Testing**: **pytest** for unit and integration tests
- **Environment Management**: **Poetry** or **pip** for dependencies management
- **Documentation**: OpenAPI automatically generated by FastAPI

## System Design

### Module Boundaries
1. **API Layer**:
   - Handles incoming requests related to teacher management, routing to the appropriate service, and returning responses.

2. **Service Layer**:
   - Contains application logic for managing teachers including creation, retrieval, and validation.

3. **Data Access Layer**:
   - Interacts with the database to manage teacher records.

4. **Models**:
   - Defines the Teacher entity and its database schema.

### Data Model
Define the `Teacher` model in `models.py`:

```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Teacher(Base):
    __tablename__ = 'teachers'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    email = Column(String, nullable=False, unique=True)
```

### API Contracts
#### 1. Create Teacher
- **Endpoint**: `POST /teachers`
- **Request Body**: 
  ```json
  {
    "name": "string",
    "email": "string"
  }
  ```
- **Response**: 
  - **201 Created** with JSON of the created teacher's details:
  ```json
  {
    "id": 1,
    "name": "John Doe",
    "email": "john@example.com"
  }
  ```

#### 2. Retrieve Teacher Information
- **Endpoint**: `GET /teachers/{teacher_id}`
- **Response**: 
  - **200 OK** with teacher's details:
  ```json
  {
    "id": 1,
    "name": "John Doe",
    "email": "john@example.com"
  }
  ```

#### 3. Fetch All Teachers
- **Endpoint**: `GET /teachers`
- **Response**: 
  - **200 OK** with JSON array of teachers:
  ```json
  [
    {"id": 1, "name": "John Doe", "email": "john@example.com"},
    {"id": 2, "name": "Jane Smith", "email": "jane@example.com"}
  ]
  ```

#### 4. Handle Missing Fields
- **Response**: **400 Bad Request** with error message:
```json
{
  "error": {
    "code": "E001",
    "message": "Missing required fields: name, email"
  }
}
```

## Implementation Steps

### Step 1: Project Setup
Ensure the project structure is as follows:
```
.
├── src/
│   ├── main.py         # FastAPI app
│   ├── models.py       # Existing models including the new Teacher model
│   ├── services/       
│   │   └── teachers_service.py  # Logic for handling teacher operations
│   ├── database.py     # DB connection and setup
│   └── routers/        
│       └── teachers_router.py     # API routes for Teacher
├── tests/              # Unit and integration tests
├── requirements.txt    # Dependency file (if required)
└── .env.example        # Example environment configuration
```

### Step 2: Database Migration
- Create a migration script to add the `teachers` table:
  - Use Alembic for managing database migrations:
    1. Generate migration file: `alembic revision --autogenerate -m "Create teachers table"`
    2. Ensure the migration script includes create statement for the `teachers` table:
      ```python
      def upgrade():
          op.create_table(
              'teachers',
              sa.Column('id', sa.Integer, primary_key=True, autoincrement=True),
              sa.Column('name', sa.String, nullable=False),
              sa.Column('email', sa.String, nullable=False, unique=True)
          )
      ```
    3. Make sure the migration does not affect existing Student or Course data.

### Step 3: Update Models
- Create a new model in `models.py` as described above for `Teacher`.

### Step 4: API Implementation
- Create API handlers in FastAPI under `routers/teachers_router.py`:

```python
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from sqlalchemy.orm import Session
from .models import Teacher
from .database import get_db  # Assuming a function to get DB session

router = APIRouter()

class TeacherCreate(BaseModel):
    name: str
    email: str

@router.post("/teachers", response_model=TeacherCreate)
def create_teacher(teacher: TeacherCreate, db: Session = Depends(get_db)):
    db_teacher = db.query(Teacher).filter(Teacher.email == teacher.email).first()
    if db_teacher:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    new_teacher = Teacher(name=teacher.name, email=teacher.email)
    db.add(new_teacher)
    db.commit()
    db.refresh(new_teacher)
    return new_teacher

@router.get("/teachers/{teacher_id}", response_model=TeacherCreate)
def read_teacher(teacher_id: int, db: Session = Depends(get_db)):
    teacher = db.query(Teacher).filter(Teacher.id == teacher_id).first()
    if teacher is None:
        raise HTTPException(status_code=404, detail="Teacher not found")
    return teacher

@router.get("/teachers", response_model=List[TeacherCreate])
def get_teachers(db: Session = Depends(get_db)):
    return db.query(Teacher).all()
```

### Step 5: Input Validation
- Perform validation for both `name` and `email` fields when creating a teacher.

### Step 6: Testing
- Write unit tests for each of the user scenarios in `tests/test_teachers.py`:

```python
import pytest
from fastapi.testclient import TestClient
from src.main import app 

client = TestClient(app)

def test_create_teacher():
    response = client.post("/teachers", json={"name": "John Doe", "email": "john@example.com"})
    assert response.status_code == 201
    assert response.json()["name"] == "John Doe"

def test_get_teacher():
    response = client.get("/teachers/1")
    assert response.status_code == 200
    assert response.json()["id"] == 1

def test_get_all_teachers():
    response = client.get("/teachers")
    assert response.status_code == 200
    assert isinstance(response.json(), list)

def test_create_teacher_missing_fields():
    response = client.post("/teachers", json={"email": "john@example.com"})
    assert response.status_code == 400
    assert response.json()["error"]["code"] == "E001"
```

### Step 7: Documentation
- Ensure proper OpenAPI documentation is generated by FastAPI to document new endpoints and request/response formats.

### Step 8: Deployment Setup
- Update Docker configurations if using Docker to ensure compatibility with changes.

## Security Considerations
- Validate and sanitize inputs to prevent XSS or SQL injection attacks.
- Ensure proper format validation for email before database insertion.

## Success Criteria
- Ensure successful creation, retrieval, and listing of teachers through API endpoints.
- Maintain a minimum test coverage of 70% for the teacher management logic.
- Successfully create database migrations that do not disrupt existing student or course data.

## Technical Trade-offs
- **Email Uniqueness**: The application checks for existing emails before creating a teacher entity, causing a potential slight delay but ensuring data integrity.

## Scalability & Maintainability
- Follow principles defined in the project constitution to ensure code consistency and support future feature additions.

## Conclusion
This implementation plan provides a structured approach to managing the new teacher entity within the existing architecture of the application while aligning with the specified requirements.

---

Existing Code Files:
1. **models.py**:
   - Add the `Teacher` model as described above.
   
2. **routers**:
   - Create a new `routers/teachers_router.py` file for API endpoints related to teacher management.

3. **tests**:
   - New tests for teacher functionality will be placed in `tests/test_teachers.py`. 

This plan serves as a comprehensive guide for implementing the necessary functionality to manage teacher entities within the educational management system, ensuring adherence to existing coding standards and practices.