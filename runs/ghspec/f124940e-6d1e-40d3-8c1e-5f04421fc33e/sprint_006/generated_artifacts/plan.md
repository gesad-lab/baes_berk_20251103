# Implementation Plan: Add Teacher Relationship to Course Entity

---
## INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Create Teacher Entity

---
## Version
1.0.0

## Purpose
To enhance the existing educational web application by establishing a relationship between the `Course` entity and the `Teacher` entity, enabling effective management of course assignments and improving communication between teachers and students.

## Architecture Overview
- **Architecture Style**: RESTful API
- **Framework**: FastAPI for building the RESTful API
- **Database**: SQLite for development and PostgreSQL for production
- **ORM**: SQLAlchemy for database interaction
- **Testing Framework**: pytest for testing
- **Containerization**: Docker for deployment (optional)

## Technology Stack
- **Backend**: 
  - **FastAPI** for handling HTTP requests and responses
  - **SQLAlchemy** for ORM
  - **Pydantic** for data validation
- **Database**:
  - **SQLite** for development and testing; **PostgreSQL** for production
- **Testing**: **pytest** for unit and integration tests
- **Environment Management**: **Poetry** or **pip** for dependencies management
- **Documentation**: OpenAPI automatically generated by FastAPI

## System Design

### Module Boundaries
1. **API Layer**:
   - Handles incoming requests related to course and teacher management, routing to the appropriate service, and returning responses.

2. **Service Layer**:
   - Contains application logic for managing teacher assignments to courses, including assignment, retrieval, and validation.

3. **Data Access Layer**:
   - Interacts with the database to manage course and teacher records.

4. **Models**:
   - Defines both `Course` and `Teacher` entities and their database schemas.

### Data Model
Update the `Course` model in `models.py` to include the `teacher_id` field:

```python
# Existing Course model
class Course(Base):
    __tablename__ = 'courses'

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    teacher_id = Column(Integer, ForeignKey('teachers.id'), nullable=True)  # New relationship field
```

### API Contracts
#### 1. Assign Teacher to Course
- **Endpoint**: `POST /courses/{course_id}/assign_teacher`
- **Request Body**: 
  ```json
  {
    "teacher_id": "int"
  }
  ```
- **Response**: 
  - **200 OK** with JSON of the updated course's details:
  ```json
  {
    "id": 1,
    "name": "Math 101",
    "teacher": {
      "id": 1,
      "name": "John Doe",
      "email": "john@example.com"
    }
  }
  ```

#### 2. Retrieve Course with Assigned Teacher
- **Endpoint**: `GET /courses/{course_id}`
- **Response**: 
  - **200 OK** with course details, including assigned teacher:
  ```json
  {
    "id": 1,
    "name": "Math 101",
    "teacher": {
      "id": 1,
      "name": "John Doe",
      "email": "john@example.com"
    }
  }
  ```

#### 3. Handle Invalid Teacher Assignments
- **Response**: **400 Bad Request** with an error message if the `teacher_id` is invalid:
```json
{
  "error": {
    "code": "E001",
    "message": "Invalid teacher_id provided"
  }
}
```

#### 4. Unassign Teacher from Course
- **Endpoint**: `DELETE /courses/{course_id}/unassign_teacher`
- **Response**: 
  - **200 OK** with JSON of the updated course's details post unassignment:
  ```json
  {
    "id": 1,
    "name": "Math 101",
    "teacher": null
  }
  ```

## Implementation Steps

### Step 1: Project Setup
Ensure the project structure is as follows:
```
.
├── src/
│   ├── main.py        # FastAPI app
│   ├── models.py      # Existing models including the updated Course model
│   ├── services/       
│   │   └── courses_service.py   # Logic for handling course operations
│   ├── database.py    # DB connection and setup
│   └── routers/       
│       └── courses_router.py      # API routes for Course
├── tests/             # Unit and integration tests
├── requirements.txt    # Dependency file (if required)
└── .env.example       # Example environment configuration
```

### Step 2: Database Migration
- Create a migration script to add the `teacher_id` field to the `courses` table.
  - Use Alembic for managing database migrations:
    1. Generate migration file: `alembic revision --autogenerate -m "Add teacher_id to courses table"`
    2. Ensure the migration script modifies the `courses` table:
      ```python
      def upgrade():
          op.add_column('courses', sa.Column('teacher_id', sa.Integer, sa.ForeignKey('teachers.id'), nullable=True))
      ```

### Step 3: Update Models
- Modify the existing `models.py` to include the added `teacher_id` in the `Course` model as shown above.

### Step 4: API Implementation
- Create API handlers in FastAPI under `routers/courses_router.py`:

```python
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from .models import Course, Teacher
from .database import get_db  # Assuming get_db provides the database session

router = APIRouter()

@router.post("/courses/{course_id}/assign_teacher", response_model=Course)
def assign_teacher(course_id: int, teacher_id: int, db: Session = Depends(get_db)):
    course = db.query(Course).filter(Course.id == course_id).first()
    if not course:
        raise HTTPException(status_code=404, detail="Course not found")
    
    teacher = db.query(Teacher).filter(Teacher.id == teacher_id).first()
    if not teacher:
        raise HTTPException(status_code=400, detail="Invalid teacher_id provided")

    course.teacher_id = teacher_id
    db.add(course)
    db.commit()
    db.refresh(course)
    return course

@router.get("/courses/{course_id}", response_model=Course)
def get_course(course_id: int, db: Session = Depends(get_db)):
    course = db.query(Course).filter(Course.id == course_id).first()
    if not course:
        raise HTTPException(status_code=404, detail="Course not found")
    return course

@router.delete("/courses/{course_id}/unassign_teacher", response_model=Course)
def unassign_teacher(course_id: int, db: Session = Depends(get_db)):
    course = db.query(Course).filter(Course.id == course_id).first()
    if not course:
        raise HTTPException(status_code=404, detail="Course not found")
    
    course.teacher_id = None
    db.add(course)
    db.commit()
    db.refresh(course)
    return course
```

### Step 5: Input Validation
- Validate that the provided `teacher_id` exists when assigning a teacher to a course and handle invalid entries appropriately.

### Step 6: Testing
- Write unit tests for each of the user scenarios in `tests/test_courses.py`:

```python
import pytest
from fastapi.testclient import TestClient
from src.main import app  # Assuming FastAPI app is instantiated in src/main.py

client = TestClient(app)

def test_assign_teacher():
    response = client.post("/courses/1/assign_teacher", json={"teacher_id": 1})
    assert response.status_code == 200
    assert response.json()["teacher"]["id"] == 1

def test_get_course_with_teacher():
    response = client.get("/courses/1")
    assert response.status_code == 200
    assert response.json()["teacher"]["id"] == 1

def test_unassign_teacher():
    response = client.delete("/courses/1/unassign_teacher")
    assert response.status_code == 200
    assert response.json()["teacher"] is None

def test_invalid_teacher_assignment():
    response = client.post("/courses/1/assign_teacher", json={"teacher_id": 99})
    assert response.status_code == 400
    assert response.json()["detail"] == "Invalid teacher_id provided"
```

### Step 7: Documentation
- Ensure proper OpenAPI documentation is generated by FastAPI to document new endpoints and request/response formats.

### Step 8: Deployment Setup
- Update Docker configurations if using Docker to ensure compatibility with new changes.

## Security Considerations
- Validate and sanitize inputs to prevent XSS or SQL injection attacks.
- Ensure proper format validation for `teacher_id` before database insertion.

## Success Criteria
- Ensure successful assignment, retrieval, and unassignment of teachers through API endpoints.
- Maintain a minimum test coverage of 70% for course-teacher relationship logic.
- Successfully create database migrations that do not disrupt existing course data.

## Technical Trade-offs
- **Input Validation**: The additional validation checks for existing teachers add slight overhead but ensure data consistency.
- The system will not allow assignments to nonexistent teachers, which enhances data integrity at the expense of user experience slight delay in error return.

## Scalability & Maintainability
- Follow principles defined in the project constitution to ensure code consistency and support future feature additions.

## Conclusion
This implementation plan provides a road map for integrating the teacher-student relationship functionality within the existing course management system. It ensures conformity to prior sprint foundations while enabling robust new features.

---

### Existing Code Files for Modification
1. **models.py**:
   - Update the existing `Course` model to include the new `teacher_id` field.

2. **routers**:
   - Create and implement new `routers/courses_router.py` for updating API routes related to course management and teacher assignments.

3. **tests**:
   - Implement new tests for courses and teacher assignment functionalities in `tests/test_courses.py`. 

This plan serves as a comprehensive guide for implementing the necessary functionality to manage teacher assignments within the educational management system, ensuring adherence to specified requirements and existing coding standards.