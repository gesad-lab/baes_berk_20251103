# Implementation Plan: Add Course Relationship to Student Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Create Course Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Add Email Field to Student Entity

## Version
1.0.0

## Purpose
To enhance the existing educational web application by adding functionality that establishes a relationship between the Student and Course entities, enabling students to enroll in multiple courses.

## Architecture Overview
- **Architecture Style**: RESTful API
- **Framework**: FastAPI for building the RESTful API
- **Database**: SQLite for development and PostgreSQL for production
- **ORM**: SQLAlchemy for database interaction
- **Testing Framework**: pytest for testing
- **Containerization**: Docker for deployment (optional)

## Technology Stack
- **Backend**: 
  - **FastAPI** for handling HTTP requests and responses
  - **SQLAlchemy** for ORM
  - **Pydantic** for data validation
- **Database**:
  - **SQLite** for development and testing; **PostgreSQL** for production
- **Testing**: **pytest** for unit and integration tests
- **Environment Management**: **Poetry** or **pip** for dependencies management
- **Documentation**: OpenAPI automatically generated by FastAPI

## System Design

### Module Boundaries
1. **API Layer**:
   - Handles incoming requests for student and course enrollments, routing to the appropriate service, and returning responses.

2. **Service Layer**:
   - Contains application logic for managing enrollment relationships between students and courses.

3. **Data Access Layer**:
   - Interacts with the database to manage student and course enrollment records.

4. **Models**:
   - Defines the Student, Course, and student_courses (join table) entities and their database schema.

### Data Model
Update models as follows:

```python
from sqlalchemy import Column, Integer, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class Student(Base):
    __tablename__ = 'students'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    
class Course(Base):
    __tablename__ = 'courses'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    level = Column(String, nullable=False)

class StudentCourse(Base):
    __tablename__ = 'student_courses'
    
    student_id = Column(Integer, ForeignKey('students.id'), primary_key=True)
    course_id = Column(Integer, ForeignKey('courses.id'), primary_key=True)
```

### API Contracts
#### 1. Enroll Student in Course
- **Endpoint**: `POST /students/{student_id}/enroll`
- **Request Body**: 
  ```json
  {
    "course_id": 1
  }
  ```
- **Response**:
  - **200 OK** with updated student record:
  ```json
  {
    "id": 1,
    "enrolled_courses": [{"course_id": 1}]
  }
  ```

#### 2. Retrieve Student Courses
- **Endpoint**: `GET /students/{student_id}/courses`
- **Response**:
  - **200 OK** with JSON array of courses:
  ```json
  [{"id": 1, "name": "Math 101", "level": "Beginner"}, ...]
  ```

#### 3. Remove Course from Student Enrollment
- **Endpoint**: `DELETE /students/{student_id}/enroll/{course_id}`
- **Response**:
  - **200 OK** with confirmation message:
  ```json
  {
    "message": "Course removed successfully"
  }
  ```

#### 4. Error Validation for Enrollment
- **Response**: 400 Bad Request with an error message if the course does not exist:
```json
{
  "error": "Course not found"
}
```

## Implementation Steps

### Step 1: Project Setup
Ensure the project structure is as follows:
```
.
├── src/
│   ├── main.py         # FastAPI app
│   ├── models.py       # Updated models including StudentCourse
│   ├── services/       # Include student_course_service.py for enrollment logic
│   ├── database.py     # DB connection and setup
│   └── routers/        # API routes for Student and Course
├── tests/              # Unit and integration tests
├── requirements.txt    # Dependency file (if required)
└── .env.example         # Example environment configuration
```

### Step 2: Database Migration
- Implement a migration script to create the `student_courses` table:
  - Use Alembic for managing database migrations:
    1. Generate migration file: `alembic revision --autogenerate -m "Create student_courses table"`
    2. Ensure the migration script includes the create statement for the `student_courses` table:
      ```python
      def upgrade():
          op.create_table(
              'student_courses',
              sa.Column('student_id', sa.Integer, sa.ForeignKey('students.id'), primary_key=True),
              sa.Column('course_id', sa.Integer, sa.ForeignKey('courses.id'), primary_key=True),
          )
      ```
    3. Make sure the migration does not affect existing Student or Course data.

### Step 3: Update Models
- Create a new model in `models.py` for the `StudentCourse` join table.

### Step 4: API Implementation
- Create API handlers in FastAPI under `routers/student_courses.py` for enrollment operations.

```python
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from sqlalchemy.orm import Session
from .models import StudentCourse, Course, Student
from .database import get_db  # Assuming a function to get DB session

router = APIRouter()

class Enrollment(BaseModel):
    course_id: int

@router.post("/students/{student_id}/enroll")
def enroll_student(student_id: int, enrollment: Enrollment, db: Session = Depends(get_db)):
    course = db.query(Course).filter(Course.id == enrollment.course_id).first()
    if not course:
        raise HTTPException(status_code=400, detail="Course not found")
    
    enrollment_record = StudentCourse(student_id=student_id, course_id=enrollment.course_id)
    db.add(enrollment_record)
    db.commit()
    return {"id": student_id, "enrolled_courses": [{"course_id": enrollment.course_id}]}

@router.get("/students/{student_id}/courses")
def get_student_courses(student_id: int, db: Session = Depends(get_db)):
    courses = db.query(StudentCourse).filter(StudentCourse.student_id == student_id).all()
    return [{
        "id": course.course_id,
        "name": db.query(Course).filter(Course.id == course.course_id).first().name,
        "level": db.query(Course).filter(Course.id == course.course_id).first().level,
    } for course in courses]

@router.delete("/students/{student_id}/enroll/{course_id}")
def remove_course_from_enrollment(student_id: int, course_id: int, db: Session = Depends(get_db)):
    enrollment = db.query(StudentCourse).filter(StudentCourse.student_id == student_id, StudentCourse.course_id == course_id).first()
    if not enrollment:
        raise HTTPException(status_code=404, detail="Enrollment not found")
    
    db.delete(enrollment)
    db.commit()
    return {"message": "Course removed successfully"}
```

### Step 5: Input Validation
- Perform validation when enrolling a student in a course ensuring the course exists.

### Step 6: Testing
- Write unit tests for each of the user scenarios in `tests/test_student_courses.py`:

```python
import pytest
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

def test_enroll_student():
    response = client.post("/students/1/enroll", json={"course_id": 1})
    assert response.status_code == 200
    assert response.json()["enrolled_courses"][0]["course_id"] == 1

def test_get_student_courses():
    response = client.get("/students/1/courses")
    assert response.status_code == 200
    assert isinstance(response.json(), list)  # Ensure it's a list

def test_remove_course_from_enrollment():
    response = client.delete("/students/1/enroll/1")
    assert response.status_code == 200
    assert response.json()["message"] == "Course removed successfully"
```

### Step 7: Documentation
- Ensure proper OpenAPI documentation is generated by FastAPI to document new endpoints and request/response formats.

### Step 8: Deployment Setup
- Update Docker configurations if using Docker to ensure compatibility with changes.

## Security Considerations
- Implement input sanitization to prevent injection attacks when saving enrollment records.
- Validate input data on the API layer with clear error messages for missing or invalid inputs.

## Success Criteria
- Ensure all CRUD operations on student enrollments are functioning as specified.
- Maintain a minimum test coverage of 70% for the new enrollment management logic.
- Successfully create database migrations that do not disrupt existing student or course data.

## Technical Trade-offs
- **Choosing SQLite vs PostgreSQL**: SQLite is simpler for development but switching to PostgreSQL for production ensures better performance and support for concurrent access.

## Scalability & Maintainability
- Follow principles defined in the project constitution to ensure code consistency and support future feature additions.

## Conclusion
This implementation plan provides a clear, structured approach to managing the enrollment functionality within the existing architecture of the application while aligning with the specified requirements.

---

Existing Code Files:
1. **models.py**:
   - Add the `StudentCourse` model as described above.
   
2. **routers**:
   - Create a new `routers/student_courses.py` file for API endpoints related to student enrollments in courses.

3. **tests**:
   - New tests for enrollment functionality will be placed in `tests/test_student_courses.py`. 

This detailed plan serves as a blueprint for the implementation of the Course relationship to the Student entity, ensuring adherence to existing coding standards and maintainability practices.