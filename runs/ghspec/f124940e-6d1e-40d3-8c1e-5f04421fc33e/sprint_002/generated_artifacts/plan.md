# Implementation Plan: Add Email Field to Student Entity

---
INCREMENTAL DEVELOPMENT CONTEXT

Previous Sprint Plan:
# Implementation Plan: Student Entity Web Application

## Version
1.0.0

## Purpose
To enhance the existing web application managing student records by adding an email field to the Student entity.

## Architecture Overview
- **Architecture Style**: RESTful API
- **Framework**: FastAPI for building the RESTful API
- **Database**: SQLite or PostgreSQL for persistent storage
- **ORM**: SQLAlchemy for database interaction
- **Testing Framework**: pytest for testing
- **Containerization**: Docker for deployment (optional)

## Technology Stack
- **Backend**: 
  - FastAPI for handling HTTP requests and responses
  - SQLAlchemy for ORM
  - Pydantic for data validation
- **Database**:
  - SQLite for development and testing; PostgreSQL for production
- **Testing**: pytest for unit and integration tests
- **Environment Management**: Poetry or pip for dependencies management
- **Documentation**: OpenAPI automatically generated by FastAPI

## System Design

### Module Boundaries
1. **API Layer**:
   - Responsible for handling incoming requests, routing to appropriate service, and returning responses.
   
2. **Service Layer**:
   - Contains application logic for creating, retrieving, updating, and deleting student records.
   
3. **Data Access Layer**:
   - Interacts with the database to manage student records.

4. **Models**:
   - Defines the Student entity and database schema.

### Data Model
```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Student(Base):
    __tablename__ = 'students'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    email = Column(String, nullable=False)  # New email field
```

### API Contracts
#### 1. Create Student
- **Endpoint**: `POST /students`
- **Request Body**: 
  ```json
  {
    "name": "John Doe",
    "email": "john.doe@example.com"
  }
  ```
- **Response**:
  - **201 Created**:
  ```json
  {
    "id": 1,
    "name": "John Doe",
    "email": "john.doe@example.com"
  }
  ```

#### 2. Retrieve All Students
- **Endpoint**: `GET /students`
- **Response**:
  - **200 OK**:
  ```json
  [
    { "id": 1, "name": "John Doe", "email": "john.doe@example.com" },
    { "id": 2, "name": "Jane Doe", "email": "jane.doe@example.com" }
  ]
  ```

#### 3. Update Student
- **Endpoint**: `PUT /students/{id}`
- **Request Body**: 
  ```json
  {
    "name": "John Smith",
    "email": "john.smith@example.com"
  }
  ```
- **Response**:
  - **200 OK**:
  ```json
  {
    "id": 1,
    "name": "John Smith",
    "email": "john.smith@example.com"
  }
  ```

#### 4. Error Validation for Email
- **Validation**: The email format must conform to standard formats (e.g., regex).
- **Response**: 400 Bad Request with error message if invalid.

## Implementation Steps

### Step 1: Project Setup
- Ensure the project structure is as follows:
  ```
  .
  ├── src/
  │   ├── main.py         # FastAPI app
  │   ├── models.py       # Update existing models to include email
  │   ├── services/       # CRUD logic
  │   ├── database.py     # DB connection and setup
  │   └── routers/        # API routes (update to handle email)
  ├── tests/              # Unit and integration tests
  ├── requirements.txt     # Dependency file (if required)
  └── .env.example         # Example environment configuration
  ```

### Step 2: Database Migration
- Implement a migration script to add the new `email` column to the `students` table without losing existing data.
- Use Alembic for managing database migrations:
  - Generate migration file: `alembic revision --autogenerate -m "Add email to students"`
  - Ensure the migration script adds the `email` column.

### Step 3: Update Models
- Modify the `Student` model in `models.py` to include the new `email` field with constraints.
  
```python
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
import re

Base = declarative_base()

class Student(Base):
    __tablename__ = 'students'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    email = Column(String, nullable=False)

    @staticmethod
    def validate_email(email: str) -> bool:
        # Email validation regex
        email_regex = re.compile(r"^[\w\.-]+@[\w\.-]+\.\w+$")
        return email_regex.match(email) is not None
```

### Step 4: API Implementation
- Update endpoint handlers in FastAPI to manage creation, retrieval, and updating of student records including the email field.
- Validate the email format at the point of input using Pydantic in request bodies.
  
### Step 5: Input Validation
- Update Pydantic models for request validation to check for valid email formats in both `Create Student` and `Update Student` endpoints.

### Step 6: Testing
- Write new unit tests to cover each user scenario; ensure tests include validation for email:
  - Test creating a student with a valid email.
  - Test retrieving all students.
  - Test updating a student's email.
  - Test validation error with an invalid email format.
- Ensure coverage is maintained and aligns with the specification requirements (70% business logic, 90% critical paths).

```python
import pytest
from fastapi.testclient import TestClient
from src.main import app

client = TestClient(app)

def test_create_student_with_email():
    response = client.post("/students/", json={"name": "Test Student", "email": "test@student.com"})
    assert response.status_code == 201
    assert response.json()["email"] == "test@student.com"

def test_create_student_with_invalid_email():
    response = client.post("/students/", json={"name": "Test Student", "email": "invalidemail"})
    assert response.status_code == 400
    assert "Invalid email format" in response.json()["detail"]
```

### Step 7: Documentation
- Leverage FastAPI's automatic documentation generation to update API docs to include the new `email` field.

### Step 8: Deployment Setup
- Update Docker configurations if using Docker to ensure compatibility with changes.

## Security Considerations
- Implement email validation and sanitize inputs thoroughly to prevent injection attacks.
- Ensure logging of validation errors without exposing sensitive information.

## Success Criteria
- The updated application will handle student records including email correctly, returning appropriate JSON responses.
- Comprehensive tests validating email and CRUD operations are in place.
- Successful migration of the database schema to add the email field without data loss.

## Technical Trade-offs
- **Email Format Validation**: Using a regex for email validation is quick but may not cover all edge cases. Consider libraries like `email-validator` for more comprehensive checks.

## Scalability & Maintainability
- Follow principles defined in the project constitution to ensure a consistent codebase, making it easier to maintain and expand the application in the future.

## Conclusion
This implementation plan outlines a structured approach to adding an email field to the Student entity, ensuring that the application continues to meet the expected performance and functionality standards as specified.

Existing Code Files:
File: `tests/test_student.py`
```python
import pytest
from fastapi.testclient import TestClient
from src.main import app  # Assuming the FastAPI app is instantiated in src/main.py

client = TestClient(app)

@pytest.fixture(scope="module")
def create_student():
    # Setup: Create a student in the database with email
    response = client.post("/students/", json={"name": "Test Student", "email": "test@student.com"})
    yield response.json()
    # Teardown: Remove the created student or reset the DB if necessary
```
